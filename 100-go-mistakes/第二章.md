# 第二章 基础篇

> 本章涵盖内容
> - 变量隐藏（Variable shadowing）
> - 日志副作用（Logging side effects）
> - 比较值（Comparing values）
> - 防止常见的JSON错误
> - 格式化网络地址
> - 处理枚举
> - 使用defer并理解如何处理参数
> - 释放资源
> - 八进制文字
> - 整数溢出
> - 使用linter工具

本章中，我们将介绍Go开发人员所犯的各种基本错误。例如，在Go中实现HTTP服务时，我们必须知道如何防止常见的JSON错误，格式化网络地址，以及如何使用defer有效的释放HTTP正文资源。我们还将看到一些所有开发人员可能已经犯过的基本错误，例如意外的变量阴影，如何在Go中处理值的比较，或者不适用linter工具。我们将深入探讨每个错误并解释什么时候会面对这样的问题以及克服这些问题的可能解决方案。

## 2.1 意外的变量隐藏
变量的作用域是指它的可见性。换句话说，程序中的名称在哪部分是有效的。在Go中，在块中声明的变量名称可以在内部块中重新声明。这种被称为变量隐藏的原则很容易出现错误。

在下面的例子中，我们将看到一个关于变量隐藏产生的bug。我们将使用两种不同的方式创建一个HTTP客户端，具体取决于tracing布尔值：

```golang
var client *http.Client	①
if tracing {
	client, err := createClientWithTracing()	②
	if err != nil {
		return err
	}
	log.Println(client)
}else {
	client, err := createDefaultClient()	③
	if err != nil {
		return err
	}
	log.Println(client)
}

//use client
```
① 生命一个client变量
② 使用带tracing的创建一个HTTP客户端，client变量在该块内被隐藏了
③ 创建一个默认的HTTP客户端，client变量在该模块依然被隐藏掉了。

首先，我们声明了一个client变量。然后，在两个内部块中，我们使用 := 操作符，也叫做短变量声明运算符。该操作符使用和开始的时候相同的名称创建了一个新的client变量；它不会为第①行中的client变量赋值。因此，在该示例中，HTTP客户端将始终是nil值。

> 注意：该代码之所以可以编译成功，是因为在logging调用中使用了内部变量client。否则，我们就会有编译错误：client declared and not used。

我们如何确保给client赋值了呢？有两种不同的方法。
第一种方法是在内部块中使用临时变量，像下面这样：
```golang
var client *http.Client
if tracing {
	c, err := createClientWithTracing()	①
	if err != nil {
		return err
	}
	client = c ②
} else {
	c, err := createDefaultClient()
	if err != nil {
		return err
	}
	client = c
}
// Use client
```
① 创建了一个临时变量c
② 将临时变量赋给变量client
变量c的生命周期只在if/else块中。然后，我们将这些变量赋值给client。

第二种方式是在内部块中使用赋值操作符（=）来将函数的返回值直接赋值给client变量。然而，它需要创建一个error变量，因为赋值运算符仅在已声明变量时才起作用。

```golang
var client *http.Client
var err error	①
if tracing {
	client, err = createClientWithTracing() ②
	if err != nil {
		return err
	}
} else {
	client, err = createDefaultClient()
	if err != nil {
		return err
	}
}
```
① 声明变量err
② 使用赋值操作符将返回来的*http.Client直接赋值给client变量

在这个例子中，我们也将内部调用的结果赋值给了client。哪种方法最好呢？第一种方法在大多数情况下都是更方便的，但是没有强迫说要是用哪种方法。

当在内部块中将一个变量名重新声明时就会发生**变量隐藏**，我们已经看到这种做法很容易出错。应根据项目和上下文制定避免隐藏变量的规则。例如，有时候，重用现有的变量名可能会很方便，像err错误。然而，一般来说，我们应该保持谨慎，因为我们已经看到我们可能会面临这样一种错误：代码可以编译，但可能不会对我们期望的变量进行赋值。在本章后面，我们将看到该如何检测变量隐藏，以帮助我们发现可能的错误。

在下一节中，我们将讨论和logging相关的副作用。

## 2.2 忽略的Logging副作用
日志是程序监控的一个重要方面。在Go或其他任何语言中使用logging时，了解其中的副作用至关重要。让我们首先回顾下Go中的logging是如何工作的。然后我们将看到为什么我们必须要谨慎的原因。

在Go的标准库中有一个内置的log包，提供了大部分基本的日志功能。它定义了一个log.Logger类型，该类型带有格式化输出的功能。它还包括一个预定义的log.Logger，可以通过helper函数进行访问：
- log.Print（未格式化），log.Printf（f代表格式化），以及log.Println（ln代表日志后跟一个新行）
- log.Fatal,log.Fatalf,以及log.Fatalln
- log.Panic,log.Panicf,以及log.Panicln

这是一个使用log.Printf的基本示例，通过给log.Printf传入一个参数，然后将消息打出到标准日志中：

```golang
package main

import "log"

func main() {
	c := count()
	log.Printf("count=%d", c) ①
}

func count() int {
	return 0
}
```
①记录变量c
上面的代码将打印出以下日志信息：
```shell
2020/12/20 12:34:38 count=0
```
现在，让我们在一个具体的例子中使用日志。如果Go应用程序是在不带参数执行的时候，我们将使用log.Fatal记录一条消息：
```golang
func main() {
	var mode string
	if len(os.Args) == 1 { ①
		log.Fatal("warning:mode is empty") ②
		mode = "default"
	}else {
		mode = os.Args[1]
	}
	log.Printf("using mode %s", mode)
	//...
}
```
① 检查是否有没有提供参数
② 记录一条致命的日志

如果我们不带任何参数运行该示例，将会输出如下信息：
```bash
2020/11/29 00:06:14 mode is empty
Process finished with exit code 1
```
正如我们所看到的，在调用log.Fatal之后程序立即退出了；它并没有继续执行。看下log.Fatal函数的实现，我们注意到下面的代码部分，该函数将会调用os.Exit(1):
```golang
func Fatal(v ...interface{}) {
	std.Output(2, fmt.Sprint(v...))
	os.Exit(1)
}
```
调用os.Exit(1)将会导致程序立即停止。这就是为什么在调用了log.Fatal函数之后应用程序就立即停止了的原因。

我们也应该记住，log.Panic函数在输出以下消息后也会导致副作用：
```golang
func Panic(v ...interface{}) {
	s := fmt.Sprint(v...)
	std.Output(2, s)
	panic(s)
}
```
我们将在错误管理章节如何正确使用panic。简而言之，这是另外一个需要考虑的副作用，因为它会阻止昂前goroutine的正常执行。

当我们使用logging库时，无论是标准的log包还是第三方logging库，我们读需要清楚的明白日志相关函数的副作用。只要我们意识到这一点，使用带有副作用的日志记录功能就不会被认为是不好的做法。我们在从一个库迁移到另外一个库的时候，我们也应该注意两个库的副作用是否相同。

在下一节中，我们将看到如何使用枚举并避免一些常见的错误。

### 2.2.1 枚举的有效性
另一个需要记住的最佳实践是当我们需要检查一个枚举值是否有效时，即值是否在定义的常量范围内。实际上，由于Go中的枚举是使用类型别名构造的，因此我们无法实现限制。例如，如果我们接收到到以下JSON内容将会发生什么？
```json
{
	"id": 1236,
	"weekday": 100 ①
}
```
① 100已经超出了星期的范围。
解析此结构体不会引起任何错误。事实上，由于Weekday类型是一个int，100也是一个合法的值。

要检查提供的weekday字段是否合法，我们可以对该值（≤7）实现一个自定义的检查方法。还有另一种方法就是在最后声明一个end常量并像下面这样实现一个有效性的检查函数：
```golang
type Weekday uint32

const (
	Unknown Weekday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
	Sunday
	end ①
)

func (w Weekday) isValid() bool {
	return w < end ②
}
```
① 私有常量
② 将值和end比较

> 注意： 常量end将保持未被导出状态（即私有状态）以便客户端不能使用它
> 
在这个实现中，有效性检查是基于和end常量比较实现的。即使新的Weekday类型值被加入，只要我们保持end畅享是在枚举列表的最后一行，那么isValid方法将始终告诉我们提供的值是否是被视为一个有效的工作日：

```golang
fmt.Println(Monday.isValid()) //true
fmt.Println(Weekday(2).isValid()) //true
fmt.Println(Weekday(100).isValid()) //false
```
总之，如果我们必须处理枚举值：
- 我们应该总是定义一个特定的类型
- 如果我们不关心枚举值，我们可以使用常量生成器iota来简化定义。否则，例如“该常量必须等于3”，那么我们不应该使用iota来处理而是指定明确的值。
- unkown应该始终分配给零值
- 要检查枚举值的有效性，我们可以通过在最后一行定义一个私有常量来实现。

现在让我们进入下一章。当我们在Go语言比较两个值时，作为Go开发者要避免哪些常见的错误？

## 2.3 不正确的值比较
在软件开发中比较值是非常常见的操作。无论是在函数中比较两个对象，还是在单元测试中将值与期望值比较，比较操作的实现使非常频繁的。在任何地方我们的第一直觉是使用 == 操作符。然而，正如我们在本节看到的，情况并非如此。那么什么时候使用 == 是合适的呢？

让我们从一个具体的例子开始。我们将创建一个customer结构体，并使用 == 操作符来比较两个实例。下面的代码将会输出什么呢？
```golang
type customer struct {
	id string
}

func main() {
	cust1 := customer{id: "x"}
	cust2 := customer{id: "x"}
	fmt.Println(cust1 == cust2)
}
```
在Go中，比较这两个customer结构体是合法的，它将会打印出true。现在，如果我们对customer结构体稍微做下修改，在其中加入一个slice的字段，那将会发生什么：
```golang
type customer struct {
	id string
	operations []float64 ①
}

func main() {
	cust1 := customer{id: "x", operations: []float64{1.}}
	cust2 := customer{id: "x", operations: []float64{1.}}
	fmt.Println(cust1 == cust2)
}
```
① 新加入的字段

我们依然期望这段代码也能够输出true。然而，它甚至都没有编译通过：
```bash
invalid operation: cust1 == cust2 (struct containing []float64 cannot be compared)
```

该问题和 == 和 != 操作符的工作原理有关。了解如何使用这两个操作符以确保我们可以有效的进行比较至关重要。如果两种类型具有可比较性，那么我们可以使用这两种运算符来比较两种不同的类型。在Go中可比较的类型包括：
- 布尔值： == 和 != 可以比较两个布尔类型的值是否相等
- 数字：== 和 != 可以比较两个数字类型的值是否相等。如果两个值具有相同的类型或能够转成成相同的类型，那么这两个操作也是可以正常编译的。
- 字符串：== 和 != 可以比较两个字符串是否相等。我们可以根据字符串的词序使用>=, < 和 > 操作符对两个字符串进行比较。
- 指针： == 和 != 可以比较两个指针是否指向了相同的内存地址或者是否都是nil。
-  通道（channels）：== 和 != 可以比较两个通道是否是由同一个make创建的或者两个都是nil

如果struct和array仅有可比较的类型组成，我们也可以将他们添加到此列表中。所以，在该列表中没有map和slice。在第一个版本中，customer结构体是由一个单一的可比较类型（一个字符串）组成的，所以使用==进行比较是合法的。相反，在第二个版本中，因为结构体customer中包含了一个slice，无法使用 == 运算符进行比较并导致了编译错误。

我们还应该知道在interface{}类型中使用 == 和 !=操作符可能存在的问题。此外，它将导致一个运行时panic：
```bash
panic: runtime error: comparing uncomparable type main.customer
```
那我们会有这样的疑问，如果我们不得不对slice、map、或者包含不能比较类型的struct进行比较的时候，该怎么办呢？如果我们不使用标准的库，另外一个方法就是使用反射和reflect.DeepEqual。该方法会之处两个元素是否是深度相等的。该函数接受的元素是基本类型，数组，结构体，切片（slice），map，指针，接口和函数。

让我们再返回第一个例子中，这次使用reflect.DeepEqual：
```golang
cust1 := cutomer{id: "x", operations: []float64{1.}}
cust2 := customer{id: "x", operations: []float64{1.}}
fmt.Println(reflect.DeepEqual(cust1, cust2))
```
这里，即使在customer结构体中包含不可比较的类型（slice），但依然会如期望的那样进行操作并输出true。

然而，在使用reflect.DeepEqual函数的时候，有两个主要方面需要注意。我们已经提到的第一个方面就是该函数区分了空集合和零值。让我们比较两个customer结构体，其中一个包含nil切片，而第二个是空切片：

```golang
var cust1 interface{} = customer{id: "x"} ①
var cust2 interface{} = customer{id: "x", operations: []float64{}} ②
fmt.Print("%t\n", reflect.DeepEqual(cust1, cust2))
```
① Nil切片
② 空切片

这段代码将打印出false，因为reflect.DeepEqual函数认为空和nil集合是不同的。这会有问题吗？当然没有。例如，如果我们想比较两个解码（unmarshaling）操作的结果，我们可能更希望提高这个差异。然而，为了有效地使用reflect.DeepEqual，有必要记住这种行为。

另一个需要关注的点在大多数语言中都是相当标准的--性能。由于此函数使用反射，因此会有性能方面的损耗。在本地使用不同大小的结构体进行一些基准测试，reflect.DeepEqual的平均执行速度要比 == 操作符慢100倍。

一把来说，我们应该记住， == 操作符的使用场景是非常有限的。例如，它不适合用于切片和map的操作。reflect.DeepEqual能解决大多数情况下的场景。但是也有一些问题，例如性能损耗。其他一些方法也是可能的，例如实现一个自定义的比较customer的函数或方法，或在单元测试中使用像google/go-cmp或stretchr/testify这样的外部库。最后要提到的是，我们还应该注意到标准库有一些现有的比较方法。例如，如果我们想比较两个字节切片，我们可以使用bytes.Compare函数。在我们寻找外部库之前，我们应该始终确保标准库是否尚未覆盖我们的用例。

在下一节中，我们将会讨论三个处理JSON数据相关的常见错误。

## 2.4 JSON处理错误
Go有对处理JSON数据很好的包支持：encoding/json 包。本节将覆盖3个和JSON编（marshaling）、解（unmarshaling）码相关的常用的错误。

### 2.4.1 空JSON
首先，让我们解决一个反复出现的问题：将一个类型编码成空JSON。我们将使用以下point结构体：
```golang
type point struct {
	x float32
	y float32
}
```
这个结构体代表一个具有两个字段的笛卡尔点：x和y。让我们创建一个point示例并使用标准的json.Marshal函数把该实例编码成一个JSON输出：
```golang
p := point{3., 2.5}
b, err := json.Marshal(p) ①
if err != nil {
	return err 
}
fmt.Println(string(b)) ②
```
① Marshal p
② b是一个[]byte变量，我们需要把它转换成可读的字符创。

不幸的的，上面的输出空：
```bash
{}
```
那么我们错过了什么？是因为我们忘记在结构体中设置JSON标签了吗？在Go中，结构体的标签是出现在字段类型定义后面的标记符。我们可以使用标签强制字段名称：
```golang
type point struct {
	x float32 `json:"x"` ①
	y float32 `json:"y"` ②
}
```
① 设置x的JSON标签
② 设置y的JSON标签

然而，输出仍然为空：{ }。实际上，对于marshal/unmarshal JSON数据的时候设置JSON标签不是必须的。默认情况下，JSON字段的名称会和结构体字段的名称相同。

是因为该类型没有被导出吗？据我们所知，在Go中，如果字段名称以大写字母开头，那么该字段是被导出的，即公开的。我们将point结构体名称重新命名为 Point：
```golang
type Point struct { ①
	x float32
	y float32
}
```
① 结构体现在是被导出了。

然而，依然是空：{ }。所以，对于marshaled/unmarshaled来说，结构体也不一定要被导出。然而，我们面临的问题是因为**在结构体内部的字段没有被导出**。那么，如果我们尝试使用这个新point结构体：
```golang
type point struct {
	X float32 ①
	Y float32 ②
}
```
① X字段现在被导出了
② Y字段现在被导出了

输出结果不再是空了：
```bash
{"x": 3, "Y": 2.5}
```
**因此，要进行marshaled/unmarshaled，结构体的字段必须被导出**。

需要注意的一点是，在marshaling中如果我们想忽略一些字段该怎么办呢？例如，我们可能想要忽略掉password字段。有两种方法。首先，正如我们所见，我们不导出这些字段。 如果由于其他外部包需要使用这些字段，我们就必须保证这些字段被导出，那么第二个方法是使用JSON标签。实际上，使用 “-”可以在marshaling/unmarshaling期间将已导出的字段忽略掉：
```golang
type Foo struct {
	A string
	b string ①
	C string `json:"-"` ②
}

f := Foo{
	A: "a",
	b: "b",
	C: "c",
}
b, err := json.Marshal(f)
if err != nil {
	return err
}
fmt.Println(string(b))
```
① 该字段被忽略是由于没被导出，即作用域是私有变量
② 该字段被忽略是因为使用了JSON的标签 "-"

因为字段b没有被导出，字段C被强制忽略了，所以将struct经过marshaled后，只包含字段A：
```json
{"A": "a"}
```
所以，要想在marshaled/unmarshaled中输出，相关的字段必须要被导出。我们不必将整个结构体类型导出或者强制使用JSON标签。我们也可以通过将字段不导出或者使用指定的JSON标签来忽略相关的字段。

在下一节中，我们将看到一个处理匿名字段时的常见错误。

### 2.4.2 缺失字段
在Go语言中，如果我们声明了一个没有名称的字段，这叫做嵌入字段。嵌入字段用于提升嵌入类型的字段和方法，我们将在下一个示例中看到：
```golang
type Event struct {
	ID int
	time.Time ①
}
```
① 嵌入的字段

time.Time是一个嵌入字段，因为它没有名称声明。如果我们创建一个Event结构体类型，我们可以在Event结构体层直接访问time.Time的方法。
 ```golang
 event := Event{}
 second := event.Second() ①
 ```
 ① 如果结构体中没有嵌入time.Time类型，例如我们在上面的结构体中指定的是一个t变量名的字段，我们要访问Second方法时需要使用下面的方法：event.t.Second()

 该Second方法被提升为可通过Event结构直接访问的方法。这就是为什么嵌入式字段主要用于结构体或接口中，而不是像int或string之类的基本类型。

 使用JSON的marshaling方法封装嵌入字段会有什么影响呢？让我们在下面的例子中找到答案。我们将实例化一个Event示例并把他marshal成JSON。下面的这段代码将输出什么呢？
 ```golang
 event := Event{
 	ID: 1234,
 	Time: time.Now(), ①
 }
 b, err := json.Marshal(event)
 if err != nil {
	return err
 }
 fmt.Printf("json: %s\n", string(b))
 ```
 ① 在实例化一个结构体的时候匿名字段的名称就是嵌入结构体的名字

 我们期望该代码输出一下信息：
 ```shell
 {"ID":1234,"Time":"2021-04-19T21:15:08.381652+02:00"}
 ```
 相反，它实际输出是这样的：
 ```shell
"2020-12-21T00:08:22.81013+01:00"
 ```
我们该如何解释这个输出呢？对于ID字段和其对应的1234值发生了什么？当这个字段被导出时，它应该已经被marshaled。要理解这个问题，我们必须澄清两件事情。

首先，如果一个嵌入字段类型实现了一个接口，那么包含该嵌入字段的结构体也将实现这个接口。从某种意义上来说，它继承了一种能力。让我们看一下下面的例子，我们定义了一个Foo结构体和一个嵌入Foo字段的Bar结构体：
```golang
 type Printer interface { ①
    print()
}
type Foo struct{}
func (f Foo) print() { ②
    fmt.Println("foo")
}
type Bar struct {
    Foo ③
}
```
① 定义了一个Printer接口和一个print()方法
② 让Foo结构体实现了Printer
③ 在Bar结构体中嵌入Foo类型

这里，由于Foo实现了Printer接口，同时Foo是Bar结构体的一个嵌入字段，所以Bar也是一个Printer类型。我们可以实例化一个Bar类型并直接调用print方法，而不通过Foo字段。

其次，我们可以通过构造一个实现了json.Marshaler接口的类型来覆盖掉默认的marshaling行为。该接口包含一个唯一的MarshalJSON方法：
```golang
type Marshaler interface {
	MarshalJSON() ([]byte, error)
}
```

下面是我们自定义marshaling的一个粒子：
```golang
type foo struct{} ①
func (_ foo) MarshalJSON() ([]byte, error) { ②
    return []byte(`"foo"`), nil ③
}
func main() {
    b, err := json.Marshal(foo{}) ④
    if err != nil {
			panic(err) 
		}
    fmt.Println(string(b))
}
```
① 定义结构体
② 实现MarshalJSON方法
③ 返回一个静态响应
④ json.Marshal方法将会依赖于自定义的MarshalJSON实现

因为我们已经覆盖了JSON的marshaling行为，所以这段代码将打印出 foo。

已经澄清了这两点，再让我们回到上面用Event结构体输出又问题的例子。我们已经知道了time.Time已经实现了json.Marshaler接口。由于time.Time是Event结构体的嵌入字段，提升了time.Time的方法到Event层级。因此，Event也实现了json.Marshaler方法。

因此，当我们传递Event到json.Marshal方法时，它不会使用默认的marshaling行文而是time.Time中提供的。这就是为什么在marshaling一个Event时导致忽略了ID字段的原因。

要解决该问题，主要有两种可能的方法。

首先，我们可以给嵌入字段time.Time命名，即不使用嵌入字段：
```golang
type Event struct {
	ID int
	Time time.Time ①
}
```
① time.Time现在不是嵌入字段了

这样，如果我们marshal该版本的Event结构体时，它将打印出如下信息：
```bash
{"ID":1234,"Time":"2020-12-21T00:30:41.413417+01:00"}
```

如果我们想保留或必须保留该time.Time为嵌入字段，另外一种选择是让Event实现json.Marshaler接口。然而，该解决方法更麻烦，而且需要确保该MarshalJSON方法始终与Event结构保持同步。

我们应该小心使用嵌入字段。虽然嵌入类型提升了其字段和方法有时会很方便，但同时也能导致细微的bug，因为父结构体也隐式的实现了该接口。当使用嵌入字段时，我么应该确保了解可能的副作用。

下一节中，我们将看到另一个使用time.Time造成的JSON错误。

### 2.4.3 JSON和单调时钟
操作系统会处理两种不同的时钟类型：墙上时钟（wall）和单调时钟（monotonic）。在本节中，我们将会看到当time.Time和JSON一起使用时可能产生的影响，并了解为什么这种时钟差异对于理解至关重要。

在下面的例子中，我们将继续使用Event结构体，但是只包含一个time.Time字段（非嵌入字段）：
```golang
type Event struct {
	Time time.Time
}
```

我们将实例化一个Event，并将它marshal成JSON，并将JSON串unmarshal成另外一个结构体。然后，我们将比较这个两个结构体。让我们看看marshaling/unmarshaling过程是否总是对称的：
```golang
t := time.Now() ①
event1 := Event{ ②
	Time: t, 
}
b, err := json.Marshal(event1) ③
if err != nil {
	return err 
}
var event2 Event
err = json.Unmarshal(b, &event2) ④
if err != nil {
	return err 
}
isEquals := event1 == event2
```
① 获取当前本地时间
② 实例化一个Event结构体
③ Marshal成JSON
④ Unmarshaling JSON成结构体实例

那么isEquals应该是什么值？它会是false，而非true。我们该如何解释呢？

首先，让我们打印event1和event2的内容：
```golang
fmt.Println(event1.Time) ①
fmt.Println(event2.Time) ②
```
① 2021-01-10 17:13:08.852061 +0100 CET m=+0.000338660
② 2021-01-10 17:13:08.852061 +0100 CET

所以，我们注意到打印的是两个不同的值。event1的值接近于event2的值，除了m=+0.000338660部分。那这部分是什么意思呢？

我们应该知道操作系统提供了两种时钟类型。首先，墙上时钟用于知道当天的当前时间。该时钟可能会发生变化。例如，如果使用NTP（网络时间协议）同步，时钟可以在时间上向后或向前跳跃。我们不应该使用墙上时钟来测量持续时间，因为我们可能会面临一些奇怪的行为，比如负的持续时间。这就是为什么操作系统提供第二种时钟类型的原因：单调时钟。单调时钟保证时间永远都是向前的，并且不会受时间跳跃的影响。它可能会受到潜在频率调整的影响（例如，如果服务器检测到本地石英的移动速度与NTP服务器不同），但不会受到时间跳跃的影响。

在Go中，并没有在两个不同的API中拆分两个类型的时钟，而是time.Time可能同时包含墙上时钟和单调时间。

当我们使用time.Now()获取本地时间时，会返回time.Time的两个时间：
```golang
 2021-01-10 17:13:08.852061 +0100 CET m=+0.000338660
------------------------------------ --------------
             Wall time               Monotonic time
```
相反，当我们解析JSON串时，time.Time字段并不包含单调时间，只有墙上时间。因此，当我们比较两个实例时，因为单调时间不一样而输出结果false。这也是我们在打印两个结构体时注意到差异的原因。

我们该如何解决这个问题呢？有两个主要选择。

当我们使用 == 操作符对两个time.Time进行比较时，它会比较结构体的所有字段包括，包括单调时间部分。为了避免这种情况，我们科室使用Equal方法作为替代：
```golang
areTimesEqual := event1.Time.Equal(event2.Time) ①
```
① true

Equal方法不会考虑单调时间。 因此，areTimesEqual会是true。然而，在这个例子中，我们只比较了time.Time字段，并没有比较它的父结构Event结构体。

第二个选择是依然保持使用 == 操作符来对两个结构体实例进行比较，但使用Truncate方法将单调时间替换成0值：

```golang
t := time.Now()
event1 := Event{
    Time: t.Truncate(0),
}
b, err := json.Marshal(event1)
if err != nil {
	return err
}
var event2 Event
err = json.Unmarshal(b, &event2)
if err != nil {
	return err 
}
isEquals := event1 == event2
```
① 去除单调时间
② 使用 == 操作符对两个结构体实例进行比较

在此版本中，这两个time.Time字段是相等的。因此，isEquals将会返回true。

总而压制，marshaling/unmarshaling处理的程序并不总是可逆的，我们会遇到在结构体中包含time.Time字段的场景。例如，我们应该牢记这一原则，以免编写错误的测试。

## 2.5 单独为IPv4协议格式化网络地址
要使用Go的标准库创建一个HTTP服务的时候，我们必须要提供一个网络地址。例如，http.ListenAndServe函数的第一个参数就是我们要使用的地址。在Go的代码仓库中经常会看到使用fmt.Sprintf函数使用主机名和端口号格式化成TCP地址：
```golang
func createHTTPServer(host, port string, handler http.Handler) error {
    addr := fmt.Sprintf("%s:%s", host, port) ①
    return http.ListenAndServe(addr, handler) ②
}
```
① 格式化TCP地址
② 服务器使用该地址来监听

传递给http.ListenAndServe作为网络地址的内容来自fmt.Sprintf函数的调用结果。这个是实现了合法的IPv4主机。例如：
- myhostname
- 127.0.0.1
- Empty 字符串

然而，如果我们使用IPv6主机呢？如果我们使用本地机器的IPv6地址运行我们的函数，将会产生如下的输出错误：
```bash
 listen tcp: address 0000:0000:0000:0000:0000:0000:0000:0001:90:
  too many colons in address
```
实际上，如果我们传递一个IPv6格式的地址给http.ListenAdnServe，它将会被格式化成如下格式：[0000:0000:0000:0000:0000:0000:0000:0001]:80。我们是否应该修改我们的实现以处理不同的逻辑来格式化地址，这取决于所使用的IP版本？

幸运的是，net包中提供了一种解决方案。我们可以使用net.JoinHostPort方法来代替fmt.Sprintf方法：
```golang
func createHTTPServer(host, port string, handler http.Handler) error {
    addr := net.JoinHostPort(host, port)
    return http.ListenAndServe(addr, handler)
}
```

net.JoinHostPort对IPv4和IPv6都兼容。如果你的公司迁移到了IPv6协议上，你也不必在每一个代码仓库中修改创建HTTP的服务。这就是为什么我们应该依赖net.JoinHostPort而不是手动操作来格式化网络地址的原因。

在下一节中，我们将看到如何处理枚举值以及最佳实践。

## 2.6 错误的处理枚举
枚举类型是由一组值组成的一种数据类型。在Go语言中，没有像enum这样的关键字。然而，处理一组值最好的实践是用类型别名和常量。然而，我们没有达到其他语言所能达到的安全水平。这就是为什么在处理枚举值时需要小心的原因。让我们来看一些相关的最佳实践以及如何避免一些常见的错误。

下面列出了一周中周几的列表：
```golang
type Weekday int ①

const (
    Monday Weekday = 0 ②
    Tuesday Weekday = 1
    Wednesday Weekday = 2
    Thursday  Weekday = 3
    Friday    Weekday = 4
    Saturday  Weekday = 5
    Sunday    Weekday = 6
)
```
① 定义一个自定义的Weekday类型
② 创建一个Weekday类型的Modany常量

创建一个Weekday类型的好处是可以强制让编译时做类型检查以及提高可读性。如果我们没有创建一个Weekday类型，那么下面的函数签名对于调用者来说可能会有一点模糊：
```golang
func GetCurrentWeekday() int {
	// ...
}
```
一个int类型可以包含任何值，同时阅读者如果没有相关的阅读文档或者代码的话也不能猜出该函数返回的是什么值。相反，如果定义一个Weekday类型，那么就会使该函数的签名更清晰：
```golang
func getCurrentWeekday() Weekday {
	// ...
}
```
在这个例子中，我们强制指定了返回具体的类型。

我们创建Weekday类型的枚举值的方法是比较合适的。然而，在Go中，还有有一种惯用的方法来声明枚举中的常量，那就是使用常量生成器 iota

> 注意：在本例中，我们还可以将Weekday声明为uint32，以强制正值并确保每个Weekday变量分配32位。

### 2.6.1 iota
iota被用于在没有明确设定常量值的情况下创建和值相关的索引。它指示编译器复制每个常量表达式，直到块结束或遇到赋值语句为止。

下面是用iota的Weekday版本：
```golang
type Weekday int
const (
    Monday Weekday = iota ①
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
    Sunday
)
```
① 使用 iota 定义枚举值

itoa的值从0开始并每行增加1。此版本等同于第一个版本：
- Monday = 0
- Tuesday = 1
- Wednesday = 3
- etc

使用 iota 允许我们避免手动定义常量值。例如，在大的枚举中手动设置常量值是会容易出错的。进一步说，我们不用对每一个变量都重复指定Weekday类型：我们定义的所有变量都是一个Weekday类型。

> 注意：我们可以在更复杂的表达式中使用iota。下面是从Effective Go中出现的一个关于处理ByteSize枚举值的例子：
> ```golang
> type ByteSize float64
> const (
> 	_ = iota ①
> 	KB ByteSize = 1 << (10 * iota) ②
> 	MB ③
> 	GB
> 	TB
> 	PB
> 	EB
> 	ZB
> 	YB
> )
> ```
> ① 通过给 _ 赋值忽略第一行的值
> ② 在该行 iota等于1，因此 KB被设置成 1 << (10 * 1)
> ③ 在这一行，iota等于2，本行将会重复上一行的表达式，因此 MB 被设置成了 1 << (10 * 2)

让我们看看在Go的枚举中如何处理未知值（unknown values）

### 2.6.2 Unknow 值
既然我们已经理解了在Go中处理枚举值的原理，让我们考虑下下面的例子。我们将实现一个HTTP处理以便将JSON格式的请求解码成Request结构体类型。该结构体将会包含一个Weekday类型的Unknown值。下面是第一版本的实现：

```golang
type Weekday int ①

const (
	Monday Weekday = iota
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
	Sunday
	Unknown ②
)

type Request struct { ③
	ID int `json:"id"`
	Weekday Weekday `json:"weekday"`
}

func httpHandler(w http.REsponseWriter, r *http.Request) { ④
	bytes, err != readBody(r) ⑤
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	
	var request Request
	err = json.Unmarshal(bytes, &request) ⑥
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	
	// Use Request
}
```
① 重用我们定义的 Weekday枚举值
② 定义Unknown常量
③ 定义一个包含Weekday字段的Request结构体
④ 实现一个HTTP处理器
⑤ 读取请求体并返回一个[]byte
⑥ 解码JSON请求体

在这个例子中，我们创建了一个Request结构体，该结构体从一个JSON请求体中解码而来。这段代码非常完整有效。在例子中，我们可以接收一个JSON内容并正确解码：
```json
{
	"id": 1234,
	"weekday": 0
}
```
这里，Weekday字段的值会等于0：Monday。

现在，如果在JSON内容中不包含weekday字段会怎么样呢？
```json
{
	"Id": 1235
}
```
解析该内容的时候将不会引起任何错误。然而，在Request结构体中的weekday字段值将会被设置成一个int类型：0值。因此，就像是在上次请求中的Monday。

那我们应该如何区分请求中是传递的Monday还是没有就没有传递weekday字段呢？这个问题和我们定义Weekday枚举的方式有关。实际上，Unknown是枚举值的最后一个值。因此，它的值应该等于7.

为了解决该问题，处理一个unknown的枚举值的最好的实践方法是将它设置成0（int类型的零值）。因此，我们应该按如下方式生命Weekday枚举值：
```golang
type Weekday int

const (
	Unknown Weekday = iota ①
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
	Sunday
)
```
① Unknow现在等于0了

如果JSON请求体中的weekday的值是空，那将会被解析成 Unknown；这就是我们所需要的。

根据经验，枚举的未知值应该设置为枚举类型的零值。这样，我们就可以区分出显示值和缺失值了。

在下一节中，我们将讨论defer关键词的使用。

## 2.7 没使用defer
在下面的例子中，我们实现了一个拷贝文件的函数。我们还将管理该文件描述符的闭包，因为一个 *os.File一旦被打开准备读写时，它就必须要使用Close函数进行关闭。最后，在函数的最后，我们将使用Sync方法来刷新文件系统的缓冲区以便将内容强制写到磁盘上，使副本持久化。这是一个可能的实现：
```golang
func CopyFile(srcName, dstName string) error {
    src, err := os.Open(srcName) ①
    if err != nil {
			return err
		}
		
    stat, err := src.Stat()
    if err != nil {
			src.Close()
			return err
		}
		
    if stat.IsDir() { ②
        src.Close()
        return fmt.Errorf("file %q is a directory", srcName)
    }
    
    dst, err := os.Create(dstName) ③
    if err != nil {
			src.Close()
			return err 
		}
		
    _, err = io.Copy(dst, src) ④
    if err != nil {
        src.Close()
        dst.Close()
        return err
		}
		
    err = dst.Sync() ⑤
    src.Close()
    dst.Close()
    return err
}
```
① 打开源文件
② 检查是否是目录
③ 创建目标文件
④ 拷贝源文件到目标文件
⑤ 刷新文件系统缓冲区

> 注意： 关闭*os.File将会返回一个错误。然而，在该例中该错误可以被安全的忽略，因为我们强制刷新了文件系统的缓冲区。否则，如果错误发生时，我们至少应该记录一条日志。在错误管理一章，我们将会看到在defer语句中如何优雅地处理错误。

这个实现使可以工作的。我们打开源文件，检查是否是目录，然后处理拷贝逻辑。然而，我们注意熬一些样板代码：
- src.Close()重复了5次
- dst.Close()重复了2次

在代码中必须考虑源文件和目标文件被关闭的路径，这使得我们的代码非常容易出错。幸运的是，Go通过defer关键词提供了一种解决该问题的方案，如图2.1：

在函数返回的时候会调用defer函数。即使在主函数panics或意外终止时defer函数也能保证被执行。调用defer会被推送到栈中。当主函数返回时，defer函数会从栈中弹出（先进后出的顺序）。这里，将会先调用c(),然后b（），最后是a（）。

> 注意：一个defer调用的时机是在函数返回时，而非在所在的块退出时。
> 如下：
> ```golang
> func main() {
>		fmt.Println("a")
>		if true {
> 		defer fmt.Print("b")
>		}
>		fmt.Print("c")
> }
> 该段代码打印结果是acb，而非abc。
> 

让我们回到CopyFile函数的例子并使用defer关键词再实现一版：

```golang
func CopyFile(srcName, dstName string) error {
    src, err := os.Open(srcName)
    if err != nil {
			return err 
		}
    defer src.Close() ①
    
    stat, err := src.Stat()
    if err != nil {
			return err 
		}
		
    if stat.IsDir() {
        return fmt.Errorf("file %q is a directory", srcName)
		}
		
    dst, err := os.Create(dstName)
    if err != nil {
			return err 
		}
    defer dst.Close() ②
    
    _, err = io.Copy(dst, src)
    if err != nil {
			return err
		}
		
    return dst.Sync()
}
```
① 延迟调用 src.Close()
② 延迟调用 dst.Close()

在这个版本的实现中，我们通过defer关键词的使用，移除了重复的close调用。这使得函数更轻量并且更易读。我们不必在每一个代码路径的末尾都关闭src和dst，这样就不容易出错了。

defer语句经常会跟成对出现的操作函数一起使用，就像 open/close,connect/disconnect,以及lock/unlock函数以确保在所有的场景下资源都能够得到释放。这是另一个使用sync.Mutex的例子：
```golang
type Store struct {
	mutex sync.Mutex
	data map[string]int
}

func (s *Store) Set(key string, value int) {
	s.mutex.Lock() ①
	defer s.mutex.Unlock() ②
	
	s.data[key] = value
}
```
① Mutex lock
② 在defer语句中unlock

我们使用s.mutex.Lock函数锁定了mutex并在defer中调用s.mutex.Unlock()函数的配对操作。

> 注意：如果我们必须实现一个pre和post操作，比如不返回任何值的
> mutex lock/unlock，我们也可以这样实现：
> ```golang
> func (s *Store) Set(key string, value int) {
> 	defer s.lockUnlock()() ①
> 	s.data[key] = value
> }
> 
> func (s *Store) lockUnlock() func() {
>		s.mutex.Lock()
>		return func() {
>			s.mutex.Unlock()
>		}
>	}
> ```
> ① 会立刻执行s.lockUnlock()，但会延迟执行s.lockUnlock()()
> 
> 延迟执行的函数调用是s.lockUnlock()()，而非s.lockUnlock()。> 因此，s.lockUnlock()部分会立即执行（s.mutex.Lock)，但是返回> 的闭包会操作被延迟执行(s.mutex.Unlock())。它添加了一些语法
> 糖，用一行代码来处理函数中的前/后操作，这有时非常方便。
> 	如果使用这种模式，还需要注意的是，面对带有两组括号的
> s.lockUnlock()() 可能会非常混乱，这取决于您团队的资历。

当重构代码时，我们还需要注意可能的影响。例如，假设我们需要将一个包含defer调用的main函数拆分成多个函数时，这种情况下，一旦应用程序执行完，defer语句并不会执行，但是当子函数执行完时defer调用才会调用：
```golang
// Before
func main() {
	consumer := createConsumer()
	defer consumer.Close() ①
	// ...
}

// After
func main() {
	consumer := handleConsumer()
	// ...
}

func handleConsumer() Consumer {
	consumer := createConsumer()
	defer consumer.Close() ②
	return consumer
}
```
① 一旦程序结束defer调用将会被执行
② 当handleConsumer函数结束defer调用才会被执行

这里，我们通过重构consumer引入了一个bug。因为一旦handleConsumer函数结束，consumer.Close()就会被执行。它看起来像一个简单的注释，但是当我们必须重构大量的代码时，有时很容易忽略defer语句。

同时也需要注意Go 1.14之前的版本，defer语句不是内联的。内联是编译器通过将函数调用直接保存在调用函数中的一种优化技术。这就是为什么在一些性能是关键因素的项目中，defer关键词很少被用到的原因。但是，在Go 1.14版本之后，defer语句可以通过内联来优化了。

总之，defer可以避免死板的代码以及减少忘记释放资源的风险，例如释放资源，断开链接，mutex解锁等等。在下一节中，我们继续讨论defer以及其参数和接受者是如何被评估的。

## 2.8 忽略了defer的参数和接收者是如何被取值的

我们已经知道一个defer语句是在其所在函数返回后才被执行的。到目前为止，我们只是用了不带参数的defer调用。然而，如果一个延迟函数带有参数，那么这些参数是如何被取值的呢？我们使用两小节的内容来深入讨论参数取值和带指针或值接受者的defer。

### 2.8.1 参数取值
在下面的例子中，我们将实现一个类似Uber的应用程序，其主要功能是为乘客找到一个最合适的司机。我们将实现一个FindDrivers函数，该函数接收一个drivers列表参数，应用两个过滤器，然后返回一个drivers子集。同时，我们还会使用logStatus和incrementStatusCounter两个函数来用于监测下面这些状态中：
- 第一个过滤器失败
- 第二个过滤器失败
- 所有的过滤器执行成功

为避免重复调用logStatus和incrementStatusCounter，我们会使用defer关键词：
```
type Status int ①

const (
	StatusSuccess Status = iota
	StatusRadiusFilterError
	StatusActivityFilterError
)

func FindDrivers(drivers []Driver) ([]Driver, error) {
	var status Status
	defer logStatus(status) ②
	defer incrementStatusCounter(status) ③
	
	var err error
	drivers, err = applyRadiusFilter(drivers)
	if err != nil {
		status = StatusRadiusFilterError ④
		return nil, err
	}
	
	drivers, err = applyActivityFilter(drivers)
	if err != nil {
		status = StatusActivityFilterError ⑤
		return nil, err
	}
	
	status = StatusSuccess ⑥
	return drivers, nil
}
```
① 定义一个Status类型枚举
② 延迟调用logStatus函数
③ 延迟调用 incrementStatusCounter函数
④ 设置status值为半径过滤错误
⑤ 设置status值为活跃过滤器错误
⑥ 设置status值为成功

首先，我们定义了一个status变量。该变量被同时传递给了logStatus和incrementStatusCounter函数。在整个函数中，依赖于可能的错误，我们更新status变量值。

如果我们尝试执行该函数，无论发生什么，我们总是会调用执行logStatus和incrementStatusCounter函数，并且status的值都是一样：StatusSuccess（0）。这怎么可能呢？

理解defer很重要的一点就是defer函数的参数是理解被取值的，而非在返回返回时。为什么这很重要呢？

在这个例子中，我们是调用的 logStatus(status)和incrementStatusCounter(status)作为延迟执行的函数。因此，Go将会使用这个阶段的status值来调度这些函数调用。因为status是通过var status Status初始化的，那它的当前值就是0，也就是StatusSuccess。

如果我们想保持使用defer，那我们怎么解决该问题呢？有两种解决方案。

第一种解决方案是给延迟执行的函数传递一个指针。指针保存的是一个变量的内存地址。即使指针值是被立即取值额，但它指向的变量的值是可能会改变的。

```golang
func FindDrivers(drivers []Driver) ([]Driver, error) {
	var status Status
	defer logStatus(&status) ①
	defer incrementStatusCounter(&status) ②
	
	var err error
	drivers, err = applyRadiusFilter(drivers)
	if err != nil {
		status = StatusRadiusFilterError
		return nil, err
	}
	
	drivers, err = applyActivityFilter(drivers)
	if err != nil {
		status = StatusActivityFilterError
		return nil, err
	}
	
	status = StatusSuccess
	return drivers, nil	
}
```
① 延迟执行函数logStatus接收一个*Status的指针类型
② 延迟执行函数incrementStatusCounter接收一个*StatusType的指针类型

我们修改logStatus和incrementStatusCounter接收一个 *Status指针，因此我们改变了调用这些函数的方式。其余的实现仍和之前一样。因为status是一个指针，当这两个函数被调度执行时，它将通过引用已更新的status值来完成。

然而，就像我们所说的，这个方案需要改变这两个函数的签名，并不是所有的时候都适用。还有第二种解决方案：通过闭包的形式来调用延迟语句。闭包是从其外部引用变量的函数值。例如：
```golang
func f() {
	s := "foo"
	go func() {
		fmt.Println(s) ①
	}()
}
```
① 在f的函数体外引用了变量s

我们已经介绍过，传给延迟函数的参数是立刻被取值的。然而，通过闭包引用的变量是在执行闭包的时候才取值的（所以，是当函数返回时）

下面是一个演示闭包是如何工作的例子：
```golang
func f() {
	i := 0
	j := 0
	defer func(i int) { ①
		fmt.Println(i, j) ②
	}(i) ③
	i++
	j++
}
① 一个做为延迟函数的闭包，接收一个整型作为输入
② i是闭包函数的输入，j是闭包外部变量
③ 传递参数i给闭包（立刻i的值）

这里，闭包引用了两个变量：i和j。i是作为函数参数传递给闭包的，所以它的值是取当前的值。相反，j是闭包外边的一个变量，所以当闭包被执行时，j的值才会被取到。如果我们运行这个例子，将会输出0 1.

因此，我们可以使用闭包来作为FindDrivers的另一个版本的实现：

​```golang
func FindDrivers(drivers []Driver) ([]Driver, error) {
    var status Status
    defer func() { ①
        logStatus(status) ②
        incrementStatusCounter(status) ③
    }() ④
    var err error
    drivers, err = applyRadiusFilter(drivers)
    if err != nil {
        status = StatusRadiusFilterError
        return nil, err
    }
    drivers, err = applyActivityFilter(drivers)
    if err != nil {
        status = StatusActivityFilterError
        return nil, err
    }
    status = StatusSuccess
    return drivers, nil
}
```
① 将闭包作为延迟函数来调用
② 在闭包中通过引用status变量来调用logStatus函数
③ 在闭包中通过引用status变量来调用incrementStatusCounter
④ 空参数列表

我们将logStatus和incrementStatusCounter的调用封装到了一个没有参数的闭包中。这个闭包引用闭包外部的变量status。因此，我们会使用status的最新的值来调用这两个函数。

现在，使用带指针或值接收者的defer又是怎么样的呢？让我们看下它是如何工作的。

### 2.8.2 指针和值接受器
当给一个方法指定接收者的时候，这个接收者可以使一个值拷贝，也可以是一个指针。简单来说，就是指针接收器可以修改接收器指向的值。想反，值拷贝接收器是原类型值的一个拷贝。

当我们在一个方法上使用defer时，会执行和参数取值相同的逻辑。使用一个值拷贝作为接收器时，接收器的值是立即被取值的：
```golang
func main() {
	s := Struct{id: "foo"}
	defer s.print() ①
	s.id = "bar" ②
}

type Struct struct {
	id string
}

func (s Struct) print() {
	fmt.Println(s.id) ③
}
```
① s是被立即取值的
② 更新s.id（不可见）
③ foo

在这个例子中，我们把print方法作为延迟函数来调用。该方法有一个值接收器，因此defer将调度该方法的执行，此时该方法的接收器是一个包含id字段值为foo的结构体。因此，该例子的输出是 foo。

相反，如果接收器是一个指针，通过指针的引用而改变的变量值是可见的：
```golang
func main() {
	s := &Struct{id: "foo"}
	defer s.print() ①
	s.id = "bar" ②
}

type Struct struct {
	id string
}

func (s *Struct) print() {
	fmt.Println(s.id) ③
}
```

① s是一个指针，它理解被取值，但当延迟方法被执行时，它可以引用另外一个变量值
② 更新 s.id（可见）
③ bar

当调用defer时，s指针也是被理解取值的。然而，该指针引用了一个结构体，该结构体的值在函数返回前发生了变化。因此，该实例的输出是bar。

总之，我们必须记住在一个方法或函数上调用defer，调用的参数是被立即取值的。对于一个方法来说，接收器也是被立即取值的。如果我们延迟取值，可以通过使用指针或闭包的方式来实现。

在下一节中，我们将继续探讨将defer用于资源相关的闭包中，因为这也是Go中一个常出错的地方。

## 2.9 未关闭资源
开发人员经常使用临时资源，这些资源必须在代码中的某个点关闭以避免泄露。例如，磁盘容量或内存。我们必须要知道那些实现了io.Closer接口的结构体类型最终都必须要关闭。

下面这个例子是一个getBody函数，该函数会构建一个HTTP GET请求并处理得到的HTTP响应。下面是第一版本的实现：
```golang
func getBody(url string) (string, error) {
    resp, err := http.Get(url)
    if err != nil {
        return "", err
    }
    body, err := ioutil.ReadAll(resp.Body) ①
    if err != nil {
        return "", err
    }
    return string(body), nil
}
```
① 读取resp.Body并将其转换成一个字节数组[]byte

我们使用了http.Get方法，然后我们使用ioutil.ReadAll解析响应值。这个函数的功能看起来算是正常的。至少，它正确返回了HTTP响应。然而，这里存在一个资源泄露的问题。让我们看看是在哪里。

resp是一个*http.Response指针类型。它包含一个io.ReaderCloser字段（io.ReadCloser同时包含io.Reader接口和io.Closer接口）。如果http.Get没有返回错误，那该字段必须被关闭。否则，就会造成资源泄露。它会占用一些内存，这些内存在函数执行后就不再需要了，但因没有主动释放资源所以不能被GC回收，同时在资源匮乏的时候客户端还不能重用TCP连接。

处理该主体关闭的最方便的方法就是使用defer语句：
```golang
func getBody(url string) (string, error) {
    resp, err := http.Get(url)
    if err != nil {
        return "", err
    }
    defer resp.Body.Close() ①
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        return "", err
    }
    return string(body), nil
}
```
① 如果http.Get没有返回错误，我们会使用defer来关闭响应值。

在该实现中，我们使用延迟函数（defer）正确处理了关闭返回资源，这样一旦getBody函数返回该延迟关闭语句就会被执行。

> 注意：我们应该消息resp.Body.Close()返回错误。我们在错误管理一章将会看到在延迟函数中如何处理错误。在这个例子以及后续的例子中，我们将暂时忽略错误。

我们应该注意的是 无论我们是否从response.Body中读取到内容，我们都需要把响应资源关闭。例如，在下面的函数中我们仅返回了HTTP状态码。然而，响应体也必须被关闭：
```golang
func getStatusCode(url string) (int, error) {
    resp, err := http.Get(url)
    if err != nil {
        return 0, err
    }
    defer resp.Body.Close() ①
    return resp.StatusCode, nil
}
```
① 即使没读取内容，响应体也需要被关闭。

我们应该确保在正确的时刻释放掉资源。例如，如果不考虑error的类型 就延迟调用resp.Body.Close():
```golang
func getStatusCode(url string) (int, error) {
	resp, err := http.Get(url)
	defer resp.Body.Close() ①
	if err != nil {
		return 0, err
	}
	
	return resp.StatusCode, nil
}
```
① 在该阶段，resp可能是nil

因为resp可能是nil，所以这段代码可能会导致程序panic：
```bash
panic: runtime error: invalid memory address or nil pointer dereference
```

最后一件关于HTTP请求体关闭需要注意的事情。一个非常少见的情况，就是如果响应是空，而非nil时关闭响应：
```golang
resp, err := http.Get(url)
if resp != nil { ①
    defer resp.Body.Close() ②
}
if err != nil {
    return "", err
}
```
① 如果response不是nil
② 作为延迟函数关闭响应体

该实现使错误的。该实现依赖一些条件（例如，重定向失败），resp和err都不是nil。然而，依据Go官方文档所说：
*出现错误时，任何都可以被忽略掉。一个返回非nil错误的非nil响应只有当CheckRedirect失败时才会出现，然而，这时返回的Response.Body已经被关闭了*

因此，if resp != nil {}的检查语句是没必要的。我们应该坚持最初的解决方案，只有在没有错误的情况下才在延迟函数中关闭主体。

> 注意： 在服务端，当实现一个HTTP handler时，不必关闭请求，因为它会被服务器自动关闭。

关闭资源以避免泄露不仅仅和HTTP的响应体有关。通常来说，所有实现了io.Closer接口的结构体都需要在某个时刻被关闭。该接口包含唯一的一个Close方法：
```golang
type Closer interface {
	Close() error
}
```
让我们看一些其他关于资源需要被关闭而避免泄露的例子：

### 2.9.1 sql.Rows
sql.Rows是用于sql查询结果的结构体。因为该结构体实现了io.Closer接口，所以它必须被关闭。我们也可以像下面这样使用延迟函数来处理关闭逻辑：
```golang
db, err := sql.Open("postgres", dataSourceName) ①
if err != nil {
    return err
}
rows, err := db.Query("SELECT * FROM MYTABLE") ②
if err != nil {
    return err
}
defer rows.Close() ③

// Use rows
```
① 创建一个SQL连接
② 执行一个SQL查询
③ 关闭 rows

如果Query的调用没有返回错误，那我们就需要及时的关闭rows。

### 2.9.2 os.File
os.File代表一个打开的文件标识符。和sql.Rows一样，最终也应该的被关闭：
```golang
f, err := os.Open("events.log") ①
if err != nil {
    return err
}
defer f.Close() ②

// Use file descriptor
```
① 打开文件
② 关闭文件标识符

当所在的函数块返回时我们又一次使用defer来调度Close方法。

> 注意：正在关闭的文件不会保证文件内容已经被写到磁盘上。事实上，写
> 入的内容可能留在了文件系统的缓冲区上，还没有被刷新到磁盘上。如果
> 持久化是一个关键因素，我们应该使用Sync()方法来把缓冲区上的内容刷
> 到磁盘上。


### 2.9.3 压缩实现
压缩的写入和读取实现也需要被关闭的。事实上，他们创建的内部缓冲区也是需要被手动释放的。例如：gzip.Writer.
```golang
var b bytes.Buffer ①
w := gzip.NewWriter(&b) ②

defer w.Close() ③
```
① 创建一个缓冲区
② 创建一个新的gzip writer
③ 关闭 gzip.Writer

gzip.Reader具有同样的逻辑：
```golang
var b bytes.Buffer ①
r, err := gzip.NewReader(&b) ②
if err != nil {
    return nil, err
}

defer r.Close() ③
```
① 创建一个缓冲区
② 创建一个新的gzip writer
③ 关闭gzip.Writer

作为本节的小结，我们已经看到，关闭有限的资源以避免泄漏是多么重要。有限的资源必须在正确的时间和特定的场景下被关闭。有时，是否需要资源不是很明确。我们只能通过阅读相关的API文档或实际实践来决定。然而，我们必须要谨慎，如果一个结构体实现了io.Closer接口，我们就必须要在最后调用Close方法。

下一节让我们看看关于八进制字符集带来的混淆。

## 2.10 八进制字符集制造的混淆
你认为下面的代码输出是什么？
```golang
sum := 100 + 010
fmt.Println(sum)
```
第一感觉，我们可能认为这段代码会输出 100 + 10的结果：110。但是，它的输出是108。这怎么可能呢？

在Go中，我们应该知道以0开头的数字被认为是八进制整数（基数是8）。八进制的10等于10进制的8。因此，上面代码中的sum = 100 + 8 = 108。读代码时一定要记住整型的这个重要特性，以免出现混淆。

八进制在不同的场合是非常有用。例如，如果我们想使用os.OpenFile打开一个文件。该函数需要传递一个uint32类型的权限参数。如果我们想匹配Linux的权限，我们就会传递一个可读的八进制数字而非十进制数字：

```golang
file,  err := os.OpenFile("foo", os.O_RDONLY, 0644)
```
而且，需要注意的是我们还可以在0的后面加一个小写的字母o：
```golang
file, err := os.OpenFile("foo", os.O_RDONLY, 0o644)
```
使用0o替代0不会有任何影响。然而，它使得八进制整数的使用更加明确易读。

> 注意：我们也可以使用大写的字母O来替代小写的字母o，但传递0O644这样的数字会增加混淆，反而没有帮助。

我们还需要其他进制的字符表示：
- 二进制：0b或0B为前缀。例如，0b100等于十进制的10。
- 十六进制：0x或0X为前缀。例如，0xF等于十进制的15。
- 虚数：以i为后缀。例如3i

最后，由于可读性的原因，我们也使用下划线作为分隔符。例如，我们可以将10亿这样写：1_000_000_000。同时我们也注意到还可以在非十进制的整数上使用下划线作为分隔符（例如，0b00_00_01)。

总之，Go处理二进制，十六进制，虚数以及8进制。8进制以0开头。然而，为了给未来的读者提高可读性和减少错误，我们应该把八进制显示的协程0o为前缀。

在下一节，我们将深入研究整型并讨论在Go中是如何处理溢出的。

## 2.11 忽略了整数溢出
在本章节中，我们将深入研究Go中是如何管理整数溢出的。但首先，让我们回想一些和整数有关的事情。

Go提供了十种整数类型。有4中带符号额整数类型：
- int8：8位
- int16：16位
- int32：32位
- int64：64位

4种无符号整数类型：
- *uint8：8位
- *uint16：16位
- *uint32：32位
- *uint64：64位

还有两种常用的整数类型：* int，*uint

这两种数据类型的大小依赖于应用程序执行的系统：在32位系统上类型的大小是32位，64位系统上则是64位。

让我们以int32类型为例，首先将其变量初始化成该类型的最大值，然后再加1。下面这段代码将会发生什么？
```golang
var counter int32 = math.MaxInt32
counter++
fmt.Printf("counter=%d\n", counter)
```
这段代码能够正常编译并运行，并没有导致panic。然而，counter++语句将产生所谓的整数溢出：
```golang
counter = -2147483648
```
然而，在运行时，整数的溢出是静默的。它不会导致应用panic。必须牢记这些行为。因为它可能悄悄的引起bug--例如，一个整数加1或加了一个正数结果却是一个负数。

在深入研究如何通过普通的操作检测整数是否溢出前，让我们思考下什么时候我们会担心它。在很多上下文中，像处理请求数或基础的加法/乘法，我们都不需要太多的担心，或者至少我们确定使用正确的整数类型。然而，在一些特殊的场景下，例如使用小整数类型来表示内存受限的项目中，必须处理大的数字，或者在进行转换时，我们可能需要检查可能的溢出情况。例如，Ariane5启动失败是由于将64位浮点转换为16位有符号整数导致溢出。

### 2.11.1 在整数递增时检查是否溢出
如果我们想在使用基础类型（int8, int16, int32, int64, uint8,uint16,uint32或uint64)递增的操作中检查是否有溢出，可以通过将该值和math常量进行比较来达到检测的目的。例如，下面是一个int32的例子：
```golang
func Inc32(counter int32) int32 {
	if counter == math.MaxInt32 { ①
		panic("int32 overflow")
	}
	return counter + 1
}
```
① 和max.MaxInt32比较

在该函数中，我们检查输入的参数是否和math.MaxInt32相等。

然而，如果一个整数类型不是已定义的类型的大小（int或uint），我们就不能使用任何标准的常量。因此，如果我们想让int或uint正常工作，我们必须手动处理这样的逻辑。

一种可能的实现是通过检查加1操作后的值是否是负数：
```golang
func IncInt(counter int) int {
    if counter <= 0 {
        return counter + 1
    }
    counter++ ①
    if counter < 0 { ②
        panic("int overflow")
    }
    return counter
}
```
① counter加1
② 检查是否是负数

我们给counter变量做加1操作；然后我们检查该变量的符号是否有改变。然而，这种实现还不是最优的，因为它需要多次检查。我们可以通过使用二进制操作来改进函数的性能。Go语言提供了以下二进制的位操作：
- &：按位与
- |:按位或
- ^:按位异或
- &^:按位清除
- <<:左移位
- >>:右移位

让我们首先处理无符号整数。如果我们想计算我们自己的maxUint常量，我们可以使用异或操作（XOR），这样可以反转整数的每一位。该常量可以通过^uint(0)进行计算得到。这是 32 位系统上出于可读性考虑的位表示：
```golang
uint(0):  00000000000000000000000000000000
^uint(0): 11111111111111111111111111111111
```

使用这个常量，我们就可以像下面这样有一个更优的实现：
```golang
const maxUint = ^uint(0) ①
func IncUint(counter uint) uint {
    if counter == maxUint { ②
        panic("uint overflow")
    }
    return counter + 1
}
```
① 创建一个maxUint常量
② 将变量值和maxUint常量值比较

相比较多次检查，我们仅将提供的值和我们的maxUint常量比较。

现在，对于增加一个有符号的int类型我们又如何用相同的逻辑实现呢？maxInt的值和maxUint的值是相同的，除了最左侧的符号位用0代替1之外。使用位的右移操作，我们可以将maxUint向右移动一位（maxUint >> 1):
```golang
maxUint:           11111111111111111111111111111111
int(maxUint >> 1): 01111111111111111111111111111111
```
然后，下面是IncInt实现的优化版本：
```golang
const (
    maxUint = ^uint(0)
    maxInt  = int(maxUint >> 1) ①
)
func IncInt(counter int) int {
    if counter == maxInt { ②
        panic("integer overflow")
    }
    return counter + 1
}
```
① 创建maxInt常量
② 和maxInt常量比较

我们还是将提供的值和我们的maxInt常量进行比较。

我们已经看到整型的加1的操作中是如何检查值是否溢出的。那关于加法的操作又是怎么检查的呢？

### 2.11.2 在加法操作中检查整数溢出

在加法操作中，我们可以通过重用maxInt常量来进行检查整数是否溢出。
```golang
const (
    maxUint = ^uint(0)
    maxInt  = int(maxUint >> 1)
)
func addInt(a, b int) int {
    if a > maxInt-b { ①
        panic("int overflow")
    }
	return a + b 
}
```
① 检查整型是否会溢出

a和b是两个操作数；如果a大于maxInt - b，就意味着该操作将会导致整数范围的溢出。

接下来，让我们再看看最后一个操作：乘法。

### 2.11.3 在乘法运算中检查整数是否溢出
乘法处理起来有点复杂。我们必须对最小整数进行检查。然而，因为在Go中没有这样的常量，我们必须要创建一个这样的最小常量。可以通过对maxInt进行反转来构建minInt，即^maxInt:

```golang
maxInt:  01111111111111111111111111111111
^maxInt: 10000000000000000000000000000000
```
实现如下：
```golang
const (
    maxUint = ^uint(0)
    maxInt  = int(maxUint >> 1)
    minInt  = ^maxInt ①
)
func multiplyInt(a, b int) int {
    result := a * b
    if a == 0 || b == 0 || a == 1 || b == 1 { ②
        return result
    }
    if a == minInt || b == minInt { ③
        panic("integer overflow")
    }
    if result/b != a { ④
        panic("integer overflow")
		}
    return result
}
```
① 创建 minInt常量
② 检查其中任何一个操作数是否等于0或1
③ 检查其中任何一个操作数是否等于minInt
④ 检查乘法运算是否导致一个整数溢出

检查乘法中的整数是否溢出需要多个步骤。首先，检查其中一个操作数是否等于0，1或minInt。然后，我们用result除以b。如果结果不等于原来的操作数(a),也就意味着一个整数溢出发生了。

总之，在Go中整数的溢出是悄悄发生的。如果我们想检查一个操作是否能够导致整数范围溢出而避免错误的话，我们可以使用本章所讲的方法来处理。我们也要知道Go中有一个专门处理大数的包：math/big。如果一个int不足以满足我们的要求，这个包就是一个很好的选择。

下一节，我们将会讨论Go的另一个重要方面：linters工具。

## 2.12 没有使用Linters工具
linter是一种可以分析代码并捕捉错误的自动化工具。本节并不会列一个详尽的现存的linters工具列表；否则，这篇只是很快就会变的过期。但是，这依然能够提醒我们有很多的很好的能够覆盖各种场景的Go linters工具，我们也应该信任他们。

例如，在前一节中，我们讨论了很多很隐藏变量相关的常见错误。在Go的工具箱中具有一个标准的linter工具，vet和shadow，就可以帮我们监测到隐藏的变量：

让我们快速看下下面的例子：
```golang
package main

import "fmt"

func main() {
    i := 0
    if true {
        i := 1 ①
    }
    fmt.Println(i)
}
```
① 隐藏的变量

vet是在Go二进制中就包含的。我们首先安装下shadow，然后和vet组合使用。然后我们运行之前的例子：
```golang
$ go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow 
go: finding golang.org/x/tools latest
go: downloading golang.org/x/tools v0.0.0-20201218024724-ae774e9781d2
go: extracting golang.org/x/tools v0.0.0-20201218024724-ae774e9781d2
$ go vet -vettool=$(which shadow) 
./main.go:8:3: declaration of "i" shadows declaration at line 6
```
① shadow安装
② 使用vettol参数将shadow链接到vet
③ Go vet可以检测隐藏的变量了

现在Go vet工具可以检测到变量i存在着一个隐藏的定义。

总之，我们需要尽可能的依赖linters工具。事实上，它给Go研发者提供了一种强大且自动化的检查代码各种问题的方式。

本节的目标不是给出一个可用的linters的列表。如果你不是一个linters的常用用户，这里有一个可用的列表，以供日常使用：
- vet：标准的Go分析工具
- golint：标准Go代码风格错误检查工具
- kisielk/errcheck：errors检查器
- fzipp/gocyclo：圈复杂度分析器
- goconst：重复的字符换常量检分析器

除了这些工具，我们也使用代码格式化工具来修复代码风格问题：
- gofmt：标准的Go代码格式化工具
- goimports：标准的Go imports格式化工具

同时，我们也可以使用golangci-lint。golangci lint是一个linting工具，它在许多有用的linter和formatter之上提供了一个facade。此外，它还允许并行运行linters，以提高分析速度。

Linters和formatters是提高我们基准代码质量和一致性强大的工具。我们一定要使用他们。

## 2.13 总结
- 避免隐藏变量能够帮助我们犯一些例如引用错误变量或阅读混乱的错误。
- 明白logging库的副作用以避免意外后果
- 在Go中为了可以进行类型比较，如果两个类型是可以比较的，我们可以使用 == 和 != 操作符：boolean，numerics，strings，指针，channels和由可比较类型组成的struct。否则，我们不得不使用reflect.DeepEqual并且需要付出使用反射的成本，或者使用自定义的实现或库。
- 使用标准的JSON库在进行编码/解码一个结构体时，结构体的字段必须是被导出的。跟是否设置了json的tag无关。
- 在结构体中，我们应该谨慎使用嵌入字段。它可能悄悄的导致了错误，像我们在本节中看到的实现了json.Marshaler接口的time.Time字段，它重新了默认的编码行为。
- 要想比较两个time.Time结构体，我们必须调用time.Time的墙上时间和单调时钟两个字段，然后使用==操作符对时间进行比较。
- 在格式化网络地址时，要能够兼容IPv4和IPv6格式，我们应该依赖于net.JoinHostPort函数。
- 定义指定的枚举类型时，需使用iota，在Go中给unknown值赋个零值是最好的实践。
- defer是非常强大且方便的解决方案，它可以避免样板代码并减少忘记释放资源操作的风险。
- 当使用defer时，我们调用的参数值是被立即取值的（在方法的上下文中如果有接收者）。
- 如果结构体实现了io.Closer接口，我们就应该在函数最后关闭该结构体以 避免出现资源泄露。
- 当我们阅读已存在的代码时，我们应该小心以0开头的整数表示是八进制。而且，为了改进可读性，我们应该尽量以0o开头来表示八进制整数。
- 在Go中会默许整数溢出的存在，所以我们要实现我们自己的函数来捕获溢出。
- 我们应该依靠现有的linter工具来捕获重要的问题和可能的错误。



















