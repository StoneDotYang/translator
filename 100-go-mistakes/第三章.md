# 代码的组织

本章涵盖内容：
- 避免嵌套代码
- 滥用init 函数
- 强制使用getters/setters方法
- 避免过度使用接口对代码造成污染
- 设计接口
- 尽量避免使用interface{}类型
- 使用可选的模式
- 组织一个Go项目
- 避免常用的包
- 保护报名冲突
- 代码文档

以一种惯用的、整洁的和表达性的方式组织一个Go代码并不是一件容易的事情。理解组织项目、处理包、以最佳方式使用接口等的所有最佳实践需要经验和错误中成长。本章我们将深入研究和代码组织结构相关的常见错误。

## 3.1 编写嵌套代码
心智模型是系统行为的内部表示。在编程时，我们必须不断维护心智模型，例如关于整体代码交互和函数实现。一段代码要具备可读性依赖于很多准则，例如命名，一致性，格式等等。一段可读的代码需要较少的认知来维护一个心智模型；因此，更容易维护。

可读性的一个关键方面就是嵌套代码的层级。我们做一个练习。假设你现在正在一个新项目上进行工作，并且不得不理解下面这个join函数的功能：
```golang
func join(s1, s2 string, max int) (string, error) {
    if s1 == "" {
        return "", errors.New("s1 is empty")
    } else {
        if s2 == "" {
            return "", errors.New("s2 is empty")
        } else {
            concat, err := concatenate(s1, s2)
            if err != nil {
				return "", err
 			} else {
    			if len(concat) > max {
        			return concat[:max], nil
    			} else {
        			return concat, nil
				}
			}
		}
	}
}

func concatenate(s1 string, s2 string) (string, error) {
    // ...
}
```
① 我们调用一个concatenate函数，该函数的功能期望是能够做一些特定的关联操作，但也可能返回一些错误

这个函数关联两个字符串并返回一个子字符串，如果长度比最大长度还大。同时，该函数还检查s1，s2以及如果调用concatenate函数时返回错误。从实现的观点来看，这个函数是正确的。但是，建立一个包含所有不同案例的心理模型可能不是一个简单的任务。为什么呢？因为嵌套级别的数量。

现在，让我们用不同的方式重新实现该函数：
```golang
func join(s1, s2 string, max int) (string, error) {
	if s1 == "" {
  	return "", errors.New("s1 is empty")
 	}
  if s2 == "" {
  	return "", errors.New("s2 is empty")
  }
  
  concat, err := concatenate(s1, s2)
  if err != nil {
  	return "", err
  }
  if len(concat) > max {
  	return concat[:max], nil
	}
  return concat, nil
}

func concatenate(s1 string, s2 string) (string, error) {

}
```
你可能已经注意到构造了新版本的心智模型需要很少的认知负荷，尽管和之前的功能是一样的。然而，我们只维护了两层嵌套。正如Go的作者Matryier在《时代》播客所说：
> 将快乐之路向左对齐；您应该能够快速地向下扫描一列以查看预期的执行流

在第一个版本中，由于很多if/else的嵌套语句，我们很分辨出期望的执行流程。相反，第二个版本只需要向下扫描一列就可以看到预期的执行流，第二列就可以看到如何处理边缘情况，如图3.1所示：

总之，函数需要的嵌套层级越多，它的阅读和理解就更复杂。让我们看看这个规则的不同应用程序，以优化代码的可读性。

### 3.1.1 条件返回
当一个if的块在所有的场景下返回时，我们应该忽略掉else块。我们不应该这么写：
```golang
if something() {
	return true
} else {
	// ...
}
```
而应该这么写，像下面这样忽略掉else：
```golang
if something() {
	return true
}
// ...
```
使用这个新版本，之前在else块内的代码被移动到了顶层，这使代码变得更容易读。

我们再看下下面这段带else块的逻辑。替换掉在else中的返回语句：
```golang
if s != "" {
	//...
} else {
	return errors.New("empty string")
}
```
我们应该反转if语句并尽早的返回：
```golang
if s == "" { ①
	return errors.New("empty string")
}
// ...
```
① 将条件从s！=“翻转” 到 if s==“”

在这个新版本中，原来在if块中的代码又被拉倒了顶层，使代码又变得可读了。

现在，让我们将这个逻辑应用到errors上。

### 3.1.2 Errors

同样的逻辑可以应用到处理错误上。为了改变可读性，快乐的路径应该被安排在左边。例如，我们不应该这样写：
```golang
value, err := something()
if err == nil {
	//...
}else {
	return err
}
```

相反，我们应该将if条件切换成如下这样：
```golang
value, err := something()
if err != nil {
	return err
}
// ...
```
新版本非常易读，因为它遵循了快乐的路径在左边，同时减少了代码块的数量。

书写可读的代码对每一位研发者来说都是非常有挑战的。努力减少嵌套块的数量，对齐左边的快乐路径，并尽早返回，这些都是提高代码可读性的具体方法。

下一节，我们将讨论在Go工程中滥用init函数的情况。

## 3.2 滥用init函数
init函数有时候会在Go应用程序中被滥用。潜在的后果可能是错误管理不善或代码流难以理解。让我们重新思考一下什么是init函数。然后，我们将看看什么时候该使用init函数，什么时候不推荐使用。

### 3.2.1 概念
一个init函数是一个没有任何参数和返回值的函数（一个func()函数）。当一个包被初始化时，在包中所有声明的常量和变量都被取值。然后，该init函数被执行。下面是一个main包的例子：
```golang
package main

import "fmt"

var a = func() int {
    fmt.Println("var") ①
    return 0
}()
func init() {
    fmt.Println("init") ②
}
func main() {
    fmt.Println("main") ③
}
```
① 首先被执行
② 第二执行
③ 最后执行

执行该例子将会有如下输出：
```shell
var
init
main
```
当一个包被初始化的时候，init函数就会被执行。在下面的例子中，我们定义了两个包，main和redis，其中main包依赖redis包。

```golang
package main

import (
	"fmt"
	"redis"
)

func init() {
	// ...
}

func main() {
	err := redis.Store("foo", "bar") ①
	// ...
}
```
① 依赖于redis包

```golang
package redis

import ...

func init() {
	// ...
}

func Store(key, value string) error {
	// ...
}
```
因为 main依赖于redis，所以会首先执行redis包的init函数，然后是main包的init函数，然后是main函数自身，如下图：

图3.2

我们在一个包中可以定义很多init函数。在这种场景中，在同一个包里的init函数的执行顺序是依赖于源码里按字母顺序执行的。例如，如果一个包里包含一个a.go和一个b.go文件，两个文件里都有init函数，a.go中的init函数将先被执行。我们不应该依赖于同一个包中的init函数的执行顺序。实际上，如果源文件被重命名会影响init的执行顺序，这是会很危险的。

我们也能在同一个文件中定义多个init函数。例如，下面的代码是非常合法的：
```golang
package main
import "fmt"
func init() { ①
    fmt.Println("init 1")
}
func init() { ②
    fmt.Println("init 2")
}
func main() {
}
```
① 该init会被先执行
② 该init会被后执行

首先定义的第一个init函数会被优先执行。
```shell
init 1
init 2
```

我们也可以使用init函数进行处理副作用。在下面的这个例子中，我们定义了一个main包，该包间接依赖于一个foo包（例如，一个公开函数的非直接调用）。然而，它包含foo包的初始化。我们可以使用 _ 操作符来进行初始化：

```golang
package main

import (
	"fmt"
	_ "foo" ①
)
func main() {
	//...
}
```
① 导入foo包以处理副作用

在这个案例中，foo包将会在main之前进行初始化。因此，foo的init函数将会被执行。

init函数的另外一个方面是它不能直接被调用：
```golang
package main

func init() {}

func main() {
	init() ①
}
```
① 不合法的引用

该代码将会产生如下编译错误：
```golang
$ go build .
./main.go:6:2:undefined:init
```
我们回顾了init是如何工作的。接下来让我们看看我们该何时使用它，何时不该使用。

### 3.2.2 何时使用init函数
在下面的例子中，我们会创建一个SQL连接。我们将使用一个init函数并构造一个可用的连接作为全局变量以供后续使用。
```golang
var connection *sql.DB
func init() {
    dataSourceName := os.Getenv("MYSQL_DATA_SOURCE_NAME") ①
    c, err := sql.Open("mysql", dataSourceName)
    if err != nil {
        log.Panic(err)
    }
    err = connection.Ping()
    if err != nil {
        log.Panic(err)
    }
    connection = c ②
}
```
① 环境变量
② 将DB连接复制给全局connection变量

我们应该如何看待我们的实现呢？让我们来描述三个主要的缺点。

第一，在init函数中的错误管理是非常受局限的。事实上，init函数中不会返回任何错误，所以，我们才决定使用panic，如果遇到一些错误时。 如果在init函数中发生了panic，是不可能从错误中恢复的，同时该应用程序将会停止。在我们的例子中，如果创建一个连接是绝对必须的，那么遇到panic就停止是可以接受的。但是，是否停止应用程序不一定要由包本身来决定。也许，调用者更希望使用重试机制或使用回调技术。在init函数中打包错误处理阻止了客户端实现错误管理的逻辑处理。

另外一个缺点和测试有关。如果我们在这个文件中加入了测试，init函数将会在执行测试用例之前执行，这不是我们期望所必须的。 例如，我们可能希望在不需要创建此连接的映射函数上添加单元测试。所以，编写单元测试的方法会很复杂。

最后一个缺点是我们创建连接的方法需要一个全局变量。全局变量有一些严重的缺点，例如：
- 它可以被包中的任何函数更改
- 它会使单元测试变得更复杂，因为依赖于共享全局状态的函数不是纯函数。

在大多数场景中，我们更喜欢封装一个变量，而不是全局变量。

这是和init函数相关的主要缺点。然而，我们是应该就避免使用它吗？当然不是。也有一些场景是适合使用init函数的。例如，官方博客使用init函数来配置静态http的配置文件：

```golang
func init() {
	 redirect := func(w http.ResponseWriter, r *http.Request) {
        http.Redirect(w, r, "/", http.StatusFound)
    }
    http.HandleFunc("/blog", redirect)
    http.HandleFunc("/blog/", redirect)
    static := http.FileServer(http.Dir("static"))
    http.Handle("/favicon.ico", static)
    http.Handle("/fonts.css", static)
    http.Handle("/fonts/", static)
    http.Handle("/lib/godoc/", http.StripPrefix("/lib/godoc/",
            http.HandlerFunc(staticHandler)))
}
```
在这个例子中，init函数不会失败（http.HandleFunc会引发panic，但也只有在handler是nil，这里不是这种情况），也没有创建任何全局变量的需要，并且也不会影响单元测试。因此，这个就是一个非常适合用init函数的例子。

总之，我们已经知道init函数可能会导致一些困难：
- 错误管理是有局限性的
- 对实现单元测试会很复杂（例如，外部依赖设置，对于单元测试来说这不是必须的）
- 如果初始化需要设置一个状态，必须通过全局变量完成

我们必须小心使用init函数。它在一些场景下会很有用，例如定义静态配置；在大多数情况下，我们应该将初始化处理为特殊函数，使代码流更显式。

## 3.3 总是使用Getters和Setters
在程序中，数据封装涉及隐藏对象的值或状态。Getters和setters是为对象的未导出字段提供了可访问的封装方法。

在Go中，没有像其他语言中的自动化的支持。使用getter和setter访问struct字段也不是强制性的，也不是惯用的。例如，标准库中的一些struct实现中一些字段是可以直接访问的，例如time.Timer结构体：
```golang
timer := time.NewTimer(time.Second)
<-timer.C ①
```
① C是一个Time类型的chan字段

因为C字段被导出了，我们甚至可以像下面这样直接修改它的值：
```golang
timer := time.NewTimer(time.Second)
timer.C = make(chan time.Time) ①
<-timer.C
```
① 修改timer的C字段

当然，我们不能这么做。然而，这个例子说明了即使是标准的库也没有强制使用getters或setters方法。

另一方面，我们也不应该禁止使用getters和setters。也有一些场景是适合使用getters和setters的。例如，一个Customer结构体中包含有一个 balance字段。我们希望通过getter和setter方法来替代直接导出该字段。如果我们这样做了，在Go中，我们应该遵循一个名为balance的字段的命名约定，如下所示：
- getter方法应该被命名成Balance
- setter方法应该被命名成SetBalance

```golang
currentBalance := customer.Balance() ①
if currentBalance < 0 {
	customer.SetBalance(0) ②
}
```
① Getter
② Setter

总之，如果结构上的getter和setter方法没有带来任何价值，我们就不应该用它们来淹没代码。我们应该讲究实用性，努力在效率和遵循在其他语言中有时被认为无可争辩的习惯之间找到适当的平衡。让我们记住，Go是一种独特的语言，设计得很简单。作为一个有效的Go程序员，也意味着试图找到最直接可行的解决方案和设计。

## 3.4 接口污染
接口污染就是用不必要的抽象来淹没我们的代码，使其更难理解和演化。如果研发者按照别的语言的习惯来使用Go中的接口的话，，那么是非常容易出错的。在深入研究该主题之前，让我们回顾一下Go中的接口。然后，我们将讨论合适适合使用接口，何时不适合使用。



### 3.4.1 Go接口
一个接口是给对象提供了特定行为的一种方式。接口是一种很多对象都可以实现的抽象方法。使Go的接口如此不同的是，它们隐式地得到了满足。例如，接口没有像implements这样显示的关键词来标识对象X实现了接口Y。

为了理解是什么使得接口如此强大，我们将从标准库中挖掘出两种流行的接口：io.Reader和io.Writer。

io包中提供了I/O原语的抽象。在这些抽象中，io.Reader涉及到从一个数据源读取数据，同时io.Writer涉及到将数据写入到目标中。如图3.3所示：

图3.3

io.Readerj接口仅包含一个Read方法：
```golang
type Reader interface {
	Read(p []byte) (n int, err error)
}
```
自定义的实现io.Reader接口的话应该接收一个字节切片，用它的数据填充该字节切片，然后返回读取数据的字节大小或返回错误。

让我们来实现io.Reader接口以看看下面的stringReader结构体时如何实现该接口的：
```golang
type stringReader struct {
	s string
}

func (r stringReader) Read(p []byte) (n int, err error) { ①
    copy(p, r.s)
    return len(r.s), nil
}
func main() {
    reader := stringReader{s: "foo"}
    p := make([]byte, 3)
    n, _ := reader.Read(p)
    fmt.Println(n, string(p)) ②
}
```
① 实现Read方法
② 3 foo

stringReader是一个io.Reader类型，因为它包含一个相同签名的Read方法。正如我们所说的，实现一个接口是隐式的。

从另一方面来说，io.Writer接口也只定义了一个方法：Write。
```golang
type Writer interface {
	Write(p []byte) (n int, err error)
}
```
实现io.Writer接口时应该将来自slice的数据写入到目标文件中，然后要么返回写入的字节数，要么返回错误。

因此，两个接口都提供了底层的抽象：
- io.Reader接口是从数据源读取数据
- io.Writer接口是将数据写入到目标源

在语言中使用这两个接口的基本原理是什么？创建这些抽象概念有什么意义？

假设我们需要实现一个函数，该函数的功能是拷贝一个文件的内容到另外一个文件。我们决定创建一个具体的函数，将两个*os.File作为输入参数。或者，我们也可以使用io.Reader和io.Writer创建一个更通用的函数：
```golang
func copySourceToDest(source io.Reader, dest io.Writer) error {
	//...
}
```
这个函数将使用*os.File参数（因为*os.File实现了io.Reader和io.Writer参数），但是，由于Go中的其他很多类型也都实现了这两个接口（io.Reader和io.Writer)，因此也可以使用标准库中的许多其他类型。同样关于测试，我们不必创建有点麻烦的临时文件，我们可以将从字符串创建的*strings.reader和作为writer的*bytes.Buffer传递给reader。

```golang
func TestCopySourceToDest(t *testing.T) {
    const input = "foo"
    source := strings.NewReader(input) ①
    dest := bytes.NewBuffer(make([]byte, len(input))) ②
    err := copySourceToDest(source, dest) ③
    if err != nil {
        t.FailNow()
    }
    got := dest.String()
    if got != input {
        t.Errorf("expected: %s, got: %s", input, got)
    }
   }
```
① 创建一个io.Reader
② 创建一个io.Writer
③ 调用copySourceToDest函数，从*strings.Reader拷贝到*bytes.Buffer中。

因此，有一个接收抽象参数而非具体类型参数的通用函数也会简化单元测试的编写。

同时，当设计接口时，需要记住接口的粒度（即接口中包含的方法）。Go中的一句谚语与接口的大小有关：

***接口越大，抽象越弱***

事实上，在接口中每增加一个方法，就会降低接口的重用性。io.Reader和io.Writer接口是很好的抽象，因为他们已经再简单不过了。当我们设计接口时，我们应该时刻保持这种原则。

总之，接口可以创建强大的抽象能力。抽象能在很多方面给我们提供帮助。例如，代码解耦，提高函数的可重用性，同时也促进单元测试。然而，就像许多软件工程领域一样，滥用一个概念会导致缺陷。

### 3.4.2 何时该使用接口

我们什么时候该使用接口呢？让我们深入的研究两个不同的接口案例，这两个案例被认为会带来一些有价值的东西。

#### 普通的行为
使用接口的第一个选择就是当很多对象都实现了相同的行为。让我们通过一个具体的例子来看一下。

我们将实现一个接收一个customers列表的函数，应用很多的过滤器，然后返回剩余的customers列表。我们首先定义三个过滤器：
- FilterByAge过滤器，通过age字段过滤
- FilterByCity过滤器，通过city字段过滤
- FilterByCount过滤器，最多返回多少个customers（例如，不超过100个）

```golang
type FilterByAge struct{ minAge int }
func (f FilterByAge) filter(customers []Customer) ([]Customer, error) ①
{
    res := make([]Customer, 0)
    for _, customer := range customers {
        if customer.age < 0 {
            return nil, errors.New("negative age")
        }
        if customer.age >= f.minAge {
            res = append(res, customer)
        }
		}
    return res, nil
}
type FilterByCity struct{ city string }

func (f FilterByCity) filter(customers []Customer) ([]Customer, error) ②
{
    res := make([]Customer, 0)
    for _, customer := range customers {
        if customer.city == f.city {
            res = append(res, customer)
				}
		}
    return res, nil
}
type FilterByCount struct{ max int }
func (f FilterByCount) filter(customers []Customer) ([]Customer, error)③
{
    if len(customers) < f.max {
        return customers, nil
		}
    return customers[:f.max], nil
}
```
① 根据age字段过滤的实现
② 根据city字段过滤的实现
③ 根据最大个数进行过滤的实现

现在我们将实现一个applyFilters方法，该方法会应用以上3个过滤器并返回最后的列表：
```golang
type filterApplication struct {
    filterByAge    FilterByAge
    filterByCity   FilterByCity
    filterByCount  FilterByCount
}
// Init filterApplication
func (f filterApplication) applyFilters(customers []Customer) (
    []Customer, error) {
    res, err := f.filterByAge.filter(customers) ①
    if err != nil {
        return nil, err
    }
    res, err = f.filterByCity.filter(customers) ②
    if err != nil {
        return nil, err
    }
    res, err = f.filterByCount.filter(customers) ③
    if err != nil {
        return nil, err
    }
    return res, nil
}
```
① 应用第一个过滤器
② 应用第二个过滤器
③ 应用第三个过滤器

该实现是可以工作的，但是我们注意到一些公式化的代码，因为所有的过滤器都实现了相同的行为：filter([]Customer)([]Customer, error)。我们应该使用接口重构我们的实现：
```golang
type Filter interface {
    filter(customers []Customer) (result []Customer, err error)
}
type filterApplication struct {
    filters []Filter
}
// Init filterApplication
func (f filterApplication) applyFilters(customers []Customer) (
    []Customer, error) {
    for _, filter := range f.filters { ①
        res, err := filter.filter(customers) ②
        if err != nil {
            return nil, err
        }
        customers = res
    }
    return customers, nil
}
```
① 迭代所有的过滤器
② 应用每一个过滤器

在这个例子汇总，我们使用接口创建了一个Filter抽象类型来帮助我们减少样板代码。我们可以通过增加更多的过滤器到filterApplication结构提中，已扩展我们的代码，applyFilters方法将会依然保持这样。

#### 单元测试
另一个中的用例是使用接口可以简化单元测试的书写。简而言之，当我们的代码有一些外部依赖项时，可以方便地将它们包装到接口中。

让我们扩展下我们之前的例子。我们将实施一种方法，对一些客户进行促销。我们将遵循的逻辑如下：
- 从数据库中获取所有的客户
- 对这些客户应用上面我们提供的这些过滤器
- 对剩下的客户进行促销，并更新数据库

我们首先看该方法的第一版本的实现。首先定义一个customerPromotion结构体，该结构体包含一个mysql.Store结构体，以实现和数据库的交互方法：
```golang
type customerPromotion struct {
	filter filterApplication ①
	storer mysql.Store ②
}

func (c customerPromotion) setPromotion() error {
    customers, err := c.storer.GetAllCustomers() ③
    if err != nil {
			return err
    }
    filteredCustomers, err := c.filter.applyFilters(customers) ④
    if err != nil {
			return err 
		}
    customerIDs := getCustomerIDs(filteredCustomers)
    return c.storer.SetPromotionToCustomers(customerIDs) ⑤
}
```
① 过滤器结构体
② 和数据库交互的结构体
③ 获取所有的客户
④ 应用过滤器
⑤ 更新数据库

现在有一个问题：我们应该如何测试该函数呢？第一种选择是创建一个测试，将MySQL实例作为先决条件。然而，这种测试不是一个单元测试。我们应该将单元测试视为在单个进程中快速且确定地运行的测试。所以，这可能不是最好的选择。

我不是在争论是否不应该测试数据库交互。例如，我们可能需要实现集成测试来验证SQL请求。然而，这些测试应该是setPromotion测试的一个补充。所以，我们该如何给这个方法实现单元测试呢？应该使用接口的方式来强制替换依赖（这里是集成的MySQL）：
```golang
 type Storer interface { ①
    GetAllCustomers() (customers []Customer, err error)
    SetPromotionToCustomers(customerIDs []string) error
}
type customerPromotion struct {
    filter filterApplication
    storer Storer ②
}
func (c customerPromotion) setPromotion() error {
    customers, err := c.storer.GetAllCustomers() ③
    if err != nil {
			return err 
		}
    filteredCustomers, err := c.filter.applyFilters(customers)
    if err != nil {
			return err 
		}
    customerIDs := getCustomerIDs(filteredCustomers)
    return c.storer.SetPromotionToCustomers(customerIDs) ④
}
```
① 创建一个接口，该接口包含在setPromotion函数中使用的两个必要方法
② 使用接口引用而非具体的实现
③ 使用Storer接口
④ 使用Storer接口

通过创建一个接口，我们已经将我们的代码从具体的实现解耦了。我们可以使用Storer接口的测试替身 来编写单元测试了。测试替身（test double）是Martin Fowler推广的概念。主要有三种测试替身（test doubles）：
- Stub：一个具有预先定义数据的对象，并用该对象来回应在测试期间的调用。
- Mock：stub对象的扩展，在这里我们还希望注册对象接收的调用以执行进一步的断言。
- Fake：工作实现，但不同于生产实现（例如hashmap）。

使用测试替身（test double），我们可以给setPromotion别写不依赖于外部数据库的单元测试。这是由于我们把外部依赖包装成了接口，所以才使此变为可能。

我们已经看到了创建接口的两种主要案例：
- 给一个共享行为创建抽象
- 将外部依赖替换成接口以简化单元测试的编写。

> 注意：本清单并非详尽无遗。它包含了理解何时使用接口有帮助的指导，但是我们可以添加的案例越多，就越依赖于实际的上下文。

在下一节，我们将会看到何时使用接口是不合适的。

### 3.4.3 何时不该使用接口
在Go项目中，接口被过度使用是很常见的。也许你具有C++或Java的背景，你会发现在具体类型之前创建接口是很自然的。然而，这不是Go中的工作方式。

像我们提到的，接口允许我们创建抽象，同时抽象应该是隐藏的，不是被创建的。换言之，如果没有直接的原因，我们不应该从在代码中创建抽象开始。我们应该努力在我们需要的时候创建接口，而不是在我们预见到我们将需要它们的时候。

如果我们过度使用接口会有什么问题呢？首先，我们应该注意到通过接口作为参数调用方法会影响性能。它需要从一个哈希表中查找接口所指向的具体类型。然而，这也不是主要问题，因为被禁止的没有多少上下文内容，但是这依然是值得被提到的点。主要的问题是接口使代码的流程变得更复杂。增加一个无用的间接调用层级不会带来任何好处；这就是通过创建无用的抽象会使代码变的更复杂的原因。

在很多案例中，如果我们只定义了一个接口，该接口只有一个具体的实现（这里我们不将测试替身算在内）并且该实现又没有包含任何外部依赖，我们可以问问自己这个接口是否是有用的。如果只是为了简化单元测试，那我们为什么不直接调用具体的实现类型呢？那我们应该如何理性对待呢？例如，如果由于一些状态使结构体变得配置起来非常复杂导致可能会出现异常时，那么我们更倾向于抽象它。然而，在一些特殊场景下，使用接口不是必须的。

总之，当在我们的代码中创建抽象时我们必须非常小心。再次强调，抽象是隐藏的，不是被创建的。对于软件开发者来说基于我们后续的需要来猜测哪些代码需要抽象是经常的事情。这个过程需要被避免，因为我们通过不必要的抽象来评估我们的代码会使我们的代码变得更复杂而难以理解。

在下一节，我们将讨论和接口相关的常见错误：在生产侧创建接口

## 3.5 在生产侧创建接口
我们已经很好的理解了什么是接口以及它只在一些特定的场景下使用。但是，我们应该在哪些地方使用接口？

经常见到的是在生产侧创建接口，然后在实现该接口。这种设计可能是使用过C++或Java语言的时候的一个习惯。然后，在Go中，很多场景下我们不应该这么做。

让我们讨论以下示例。我们实现了一个包来存储并获取客户数据。我们也决定客户端可以通过以下接口来访问我们的包：
```golang
type Storer interface {
    StoreCustomer(customer Customer) error
    GetCustomer(id string) error
    UpdateCustomer(customer Customer) error
    GetAllCustomers() ([]Customer, error)
    GetCustomersWithoutContract() ([]Customer, error)
    GetCustomersWithNegativeBalance() ([]Customer, error)
}
```
我们肯定会认为我们已经有了非常完美的理由来这么做。可能这是将客户端从具体实现中解耦的好方式？可能通过接口能帮助客户端创建测试替身？然而，这不是一个最贱实践。

主要原因和我们在上一节讨论的类似：抽象是隐藏的，不是被创建的。生产者不必为所有客户端强制执行给定的抽象。相反，应该由客户端来决定它是否需要抽象，然后决定它最需要的抽象层级是什么。

在上一个例子中，可能一个客户端会需要使用所有的6个方法。但是也许另一个客户仅仅需要使用GetAllCustomers方法，而不需要Storer所有的方法来创建一个测试替身。最好的方法是公开生产者端的具体类型，让客户决定是否使用接口和最佳粒度。

为了完整起见，让我们涉及到这个方法，在生产侧的接口，时常用在标准库中。例如，例如，encoding包定义了由其他子包（如encoding/json或encoding/binary）实现的接口。那么这个实现是反模式的吗？当然不是。在这个特殊的案例中，在encoding包中定义的抽象是在标准库被使用的，语言设计者知道提前创建这些抽象的好处。

总之，如果没有针对以下问题的有力论据，就不应该在生产者端创建接口：这种抽象对我的客户端有帮助吗？

在下一节中，我们将讨论和interface{}类型相关的一个常见错误。

## 3.6 interface{} 没有告诉我们任何东西

在Go中，众所周知，一个没有任何方法的接口是空接口。一个空接口可以容纳任何值的类型：
```golang
func main() {
    var i interface{}
    i = 42 ①
    i = "foo" ②
    i = struct { ③
			s string 
		}{
				s: "bar", 
		}
		i= f ④
		_= i ⑤
}

func f() {}
```
① 一个int类型
② 一个字符串类型
③ 一个结构体
④ 一个函数
⑤ 赋值使示例可以编译

在将一个值赋给interface{}类型时，我们丢失了所有需要类型断言才能从变量i中获得有用信息的类型信息。

让我们看一个具体的例子。我们将实现一个Store结构体以及两个方法：Get和Set。这些方法将被用于存储不同的结构体类型：Customer和Contract：
```golang
package store
type Customer struct{
    // Some fields
}
type Contract struct{
    // Some fields
}
type Store struct{}
func (s *Store) Get(id string) (interface{}, error) { ①
    // ...
}
func (s *Store) Set(id string, v interface{}) error { ②
    // ...
}
```
① 返回一个空接口
② 接收一个空接口

虽然在Store的编译方面没有任何问题，但是我们应该花点时间思考下导出方法的语义。由于我们接收并返回的都是一个空接口，但这个方法缺少表现力。如果一个研发者必须要使用Store结构体，它很有可能不得不深入研究相关的文档或阅读代码来理解应该如何使用这些方法。因此，接受或返回一个空接口并没有传递出一个有意义的信息。

而且，在编译期间也没有任何安全检查，没有什么可以阻止调用者使用任何数据类型调用这些方法：
```golang
s := store.Store{}
s.Set("foo", 42)
```
通过使用空接口，我们失去了静态语言的一些优势。

相反，我们应该尽量避免使用空接口并且让我们的方法签名具有具体的类型。我们甚至可以这样写：
```golang
type Store struct{}
func (s *Store) GetContract(id string) (Contract, error) {
    // ...
}
func (s *Store) SetContract(id string, contract Contract) error {
    // ...
}
func (s *Store) GetCustomer(id string) (Customer, error) {
    // ...
}
func (s *Store) SetCustomer(id string, customer Customer) error {
    // ...
}
```
在这个版本中，方法都是具有表现力的。它降低了消费者对这个包装不理解的风险。同时，我们也可以使用接口来创建一个最小的抽象。例如，如果一个消费者只对和联系方式有关的方法感兴趣，他可以创建一个只包含这两个方法的接口：
```golang
type Storer interface {
    GetContract(id string) (store.Contract, error)
    SetContract(id string, contract store.Contract) error
}
```
那么，我们又为什么在语言中有空接口呢？又有哪些场景是适合用空接口的呢？让我们看一个标准库。我们可以注意到空接口的多种用法，例如json.Marshal，编码一个输入值：
```golang
func Marshal(v interface{}) ([]byte, error) {
	//...
}
```

另一个例子是在sql包中当执行一个查询时，使用空接口作为不定参数来传递：
```golang
func (c *Conn) QueryContext(ctx context.Context, query string, args ...interface{}) (*Rows, error)
    // ...
}
```
总之，如果确实需要接受或返回任何可能的类型，那么空接口是有用的。例如：
- Marshaling任何类型
- 接受任何类型以格式化

通常来说，我们应该不惜一切代价避免过度概括我们编写的代码。如果代码能够在其他方面有所改进，那么有时候存在一些重复的代码也是值得的，比如在代码表现力方面。

既然我们已经讨论了使用空接口类型的缺点，下一节我们将讨论选项配置的常见模式。

## 3.7 不使用函数式选项模式

本节将通过一个常见的用例来展示如何使API方便且友好地接受选项配置。我们将深入研究不同的选项，以达到最后展示一个在Go中流行的解决方案：函数式选项模式。

假设我们必须设计一个库，并暴露一个函数接口来创建一个HTTP服务器。该函数将接受不同的输入：一个地址和一个端口。该函数的签名如下：
```golang
func NewServer(addr string, port int) (*http.Server, error) {
	// ...
}
```

使用者开始使用这个函数，并且所有人都很开心。然而，在某个时间点，客户开始抱怨该函数有一些限制并缺少一些其他参数（例如，超时时间，连接上下文）。然而，这时我们开始注意到如果我们增加一个新的参数，它将会破坏兼容性，会强制使用者修改他们已经调用过的NewServer函数。

与此同时，我们也希望扩展与端口管理相关的逻辑，像图3.4展示的这样：

图3.4

- 如果端口号没有设置，则使用默认值
- 如果端口号是负数，则返回错误
- 如果端口号是0，则使用随机端口
- 否则，使用用户提供的端口号

我们该如何以API友好的方式实现这个函数呢？让我们来看看所有的不同实现。

### 3.7.1 传一个配置结构体（Config struct）
第一种方法是使用一个结构体（config struct）来处理不同的配置选项。我们可以把参数分成两类：基础配置和可选配置。基础配置参数可以作为函数参数，可选参数在config结构体中处理：

```golang
type Config struct {
    Port        int
}
func NewServer(addr string, cfg Config) {
}
```
这种解决方案修复了兼容性的问题。如果我们增加了新的配置选项，它也不会中断客户端的调用。然而，这种方法没有解决端口管理相关的需求。事实上，我们应该知道如果结构体的字段没有提供，那默认将会被初始化成零值：
- int类型的零值是0
- 浮点类型的零值是0.0
- 字符串的零值是“”
- slice、map、channels、指针、接口和函数的零值是nil

因此，在下面的例子中两个结构体时相等的：
```golang
c1 := httplib.Config{
	Port:0, ①
}

c2 := httplib.Config{
	②
}
```
① Port被初始化成0
② Port字段缺失，所以初始值也是0

在我们的例子中，我们需要找到一种方法来正确区分端口号是被设置成了0还是没有提供port字段。一种可能的方法是将结构体的字段都定义成指针类型：
```golang
type Config struct {
	Port *int
}
```
这种方式也会工作，但有两个缺点。首先，客户端提供整型指针并不方便。客户端必须要创建一个变量并且要以指针的形式传递：
```golang
port := 0
config := httplib.Config{
	Port: &port, ①
}
```
① 提供一个整型指针

它本身并不是一个令人惊叹的东西，但整体 API 变得不那么方便使用。

第二个缺点是使用我们库的客户端，如果是带默认配置的话，客户端必须要传递一个空结构体：
```golang
httplib.NewServer("localhost", httplib.Config{})
```
这段代码看起来不是很好。阅读者不得不思考这个魔幻的struct是什么意思。

在下一节，我们将介绍另外一种方式：使用经典的构造器模式来实现。

### 3.7.2 构造器模式
构建器模式为各种对象创建问题提供了灵活的解决方案。让我们看看这种模式是如何帮助我们设计一个友好的API的，以满足我们所有的需求，包括端口号的管理。
```golang
type Config struct { ①
    Port int
}
type ConfigBuilder struct { ②
    Port *int
}
func (b *ConfigBuilder) Port(port int) { ③
    b.Port = &port
}

func (b *ConfigBuilder) Build() (Config, error) { ④
    cfg := Config{}
    if b.Port == nil { ⑤
        cfg.Port = defaultHTTPPort
    } else {
        if *b.Port == 0 {
            cfg.Port = randomPort()
        } else if *b.Port < 0 {
            return Config{}, errors.New("port should be positive")
        } else {
            cfg.Port = *b.Port
        }
		}
    return cfg, nil
}

func NewServer(addr string, config Config) (*http.Server, error) {
    // ...
}
```
① 定义Config结构体
② 定义ConfigBuilder结构体，包含一个可选的port字段
③ 设置port的public方法
④ Build方法创建一个config结构体
⑤ 管理Port的主要逻辑

下面是客户如何使用我们基于构建器的API（我们假设已经把我们的代码放在了httplib包中）：
```golang
builder := httplib.ConfigBuilder{} ①
builder.Port(8080) ②
cfg, err := builder.Build() ③
if err != nil {
	return err 
}
server, err := httplib.NewServer("localhost", cfg) ④
if err != nil {
	return err 
}
```
① 创建一个ConfigBuilder结构体
② 设置port
③ 构建config结构体
④ 给函数传递config结构体

这种方法使端口管理更方便。由于该Port方法接受的是一个整型参数，所有没有必要传递一个整型指针。然而，依然需要传递一个空的config结构体，如果客户端只需要默认的配置情况下。

> 注意：该方法有不同的变体。例如，一种变体是NewServer接收一个ConfigBuilder结构体，然后再函数内部构建config。然而，不管怎样，都必须要传递一个config对象的问题。

在某些场景下，另外一个缺点是和错误管理相关的。在程序语言中，异常被跑出的地方，在builder的Port方法中，如果输入的参数是非法的，就会抛出异常。在Go中，我们不能让构建方法返回错误。事实上，构造器模式一般被认为是用组合的模式进行调用的（例如：builder.Port(8080).Timeout(time.Second).Certificate(cert)）。我们不想让客户端每次都检查错误。因此，在Build方法中推迟了校验。在一些场景中，这对客户端来说可能不具备表现力。

现在我们来看另一个模式，叫做函数选项模式，它依赖于变量参数。

### 3.7.3 函数选项模式

我们要深入研究的最后一种方法是函数选项模式。虽然有不同的实现中有一些小的变化，但其主要思想下面介绍的相同：
图3.5

每一个选项（例如WithPort）都返回一个Option接口的具体实现，该实现将会更新options结构体，包含最后的配置。该结构体是私有的：
```golang
type options struct {
	port *int
}
```
同时，我们需要创建一个公开的Option接口和一个私有的applyOptions方法：
```golang
type Option interface {
	apply(*opitons) error ①
}

type applyOptions struct {
    f func(*options) error ②
}
func (ao *applyOptions) apply(opts *options) error {
    return ao.f(opts) ③
}
```
① Option接口由一个apply方法构成
② f 字段是一个函数引用，该函数包含了如何更新config结构体的逻辑
③ applyOptions结构体实现了apply方法，该方法中调用了内部的f 函数

整个逻辑在内部的 f 函数字段上。该 f 字段是被客户端使用公开的方法创建的。例如，WithPort方法：
```golang
func WithPort(port int) Option {
    return &applyOptions{
			f: func(options *options) error { ①
    		if port < 0 {
        	return errors.New("port should be positive")
    		}
    		options.port = &port
				return nil 
			},
	}
}
```
① 初始化 f 字段，该f字段提供了一段校验输入并且更新config结构体的逻辑

每一个配置字段都需要创建一个包含简单逻辑的公开方法（为了方便一般以With前缀开头）：如需要，则要验证输入参数的合法性以及说明如何更新config结构体。

现在，让我们深入研究供给侧的最后一部分，如何使用这些可选项：
```golang
func NewServer(addr string, opts ...Option) (*http.Server, error) { ①
    var options options ②
    for _, opt := range opts { ③
        err := opt.apply(&options) ④
        if err != nil {
            return nil, err
        }
		}

		// At this stage, the options struct is built and contains the config
		// Therefore, we can implement our logic related to port configuration
		var port int
		if options.port == nil {
				port = defaultHTTPPort
		} else {
        if *options.port == 0 {
            port = randomPort()
        } else {
            port = *options.port
				}
		}
		// ... 
}
```
① 接受一个可变的Options参数
② 创建一个空options结构体
③ 循环迭代所有的输入options
④ Apply每一个option，该函数将会修改普通的options结构体

因为NewServer接受一个可变的Option参数，客户端可以通过传递0个或多个options来使用该API：
```golang
// No options
server, err := httplib.NewServer("localhost")
// Multiple options
server, err := httplib.NewServer("localhost", httplib.WithPort(8080),
httplib.WithTimeout(time.Second))
```
多亏有可变参数，如果客户端需要默认配置，它不需要提供一个空结构体，就像我们在前面看到那样调用：
```golang
server, err := httplib.NewServer("localhost")
```
这就是函数选项模式。它给API接口提供了一种方便且友好的方式来处理可选参数。虽然构建模式也是一个有效的方式，但还是存在一些缺点，以至于使用函数选项模式才是最理想的处理方式。这种模式在很多库中都被应用，例如gRPC。

下一节，我们将深入研究一个普遍的错误：Go工程代码的组织。

## 3.8 项目组织混乱

组织一个Go项目不是一件容易的事情。经常会发现项目的结构缺乏连贯性。本节将首先研究一个标准的项目结构，然后讨论几个最佳实践，展示如何改进我们组织项目的方式。

### 3.8.1 项目结构
对于如何在Go中构造一个项目，语言维护人员并没有给出一个强制的约束规则。然而，有一个相对的标准的规范：
[golang-standards/project-layout](https://github.com/golang-standards/project-layout)

如果你的项目足够小（仅有几个文件），或者你的公司已经创建了自己的标准，使用或迁移到上述的标准中则意义不大。否则，可以考虑遵从上述项目结构。我们深入研究下该项目结构并看看主要的目录：
- /cmd ：主要的源码文件。foo应用程序的main.go文件应该在/cmd/foo/main.go中
- /internal： 私有代码，我们不希望被其他应用程序或库导入的部分。
- /pkg:：公开的代码，可以被导出的部分
- /test：测试文件和测试数据。Go中的单元测试和源码文件是在同一个包中的。然而，API接口的测试或继承测试应该放在/test目录下
- /config：配置文件
- /docs：用户设计文档或说明文档
- /examples：程序或公开库的使用示例
- /api：API接口文件（例如，Swager，Protocol Buffers，等）
- /web：web应用的附件（静态文件等）
- /build：打包和CI文件
- /scripts：分析，安装脚本等
- /vendor：应用依赖的包（例如，Go模块依赖）

也许你已经注意到，没有/src目录。因为/src目录太常用了，该目录结构更喜欢使用像/cmd,/internal,/pkg这样的目录。

在跨组织中，使用这样一套标准的目录结构对于保持一致性是非常明智的选择。相反，对于在项目中重复造轮子相比，使用标准的目录结构也会是一个好主意。

我们涉及到的主要逻辑都应该在/internal和/pkg目录中。下一节我们将讨论如何组织我们的主要逻辑。

### 3.8.2 包的组织
在Go中，没有子包的概念。然而，我们可以使用子目录来组织包结构。如果我们看过标准库，会发现net文件夹是这样被组织的：
```golang
/net
		/http
				client.go
				...
		/smtp
				auth.go
				...
		addrselect.go
		...
```
我们可以看到 net 即使一个报名，也是一个包含其他包的目录名。但是http包并没有继承net包，并且有一些特定的访问net包。在http中的元素仅能看到net中导出的元素。

因此，子目录的主要好处是将包保持在具有高内聚性的地方。这里的http依赖于net（例如，net.Conn），但这不是强制的。关于使用目录的最佳方式，有不同的学派：我们是按特点还是按层次组织？这取决于你喜欢什么，显然，这不是本节的范围。但是，我们应该记住，子目录可以帮助我们组织代码。

关于包的组织，我们有很多的最佳实践。

首先，我们应该避免过早打包，因为它可能会导致项目过于复杂。有时候，最好保持一个简单的组织，当我们理解了项目所包含的内容时，让我们的项目不断发展，而不是强迫自己事先拥有一个完美的结构。

粒度是另一件需要考虑的事情。我们应该避免出现大量只包含一到两个文件的微小的包。如果我们这样做了，那是因为我们可能错过了这些包之间的一些逻辑连接，使得我们的项目更难让读者理解。相反地，我们也应该避免使用会淡化包名含义的大型包。

包命名也应该小心。正如所有开发人员已经经历过的那样，命名是很困难的。我们应该根据包提供的内容来命名包，而不是根据包包含的内容来帮助客户理解Go项目。同样，出于同样的原因，命名应该是有意义的。因此，包名称应该简短、简洁、富有表现力。按照惯例，包应该是小写的单字名称。

关于导出什么，规则非常简单。我们应该尽可能减少应该导出的内容，这样可以减少包之间的耦合，并隐藏不必要的导出元素。如果我们不确定是否导出一个元素，我们应该默认不导出它。以后，如果我们发现需要导出它，我们可以调整代码。我们还要记住一些特定的情况，比如将字段导出到可以使用encoding/json对struct进行解码的结构。

这些是一些与包组织相关的标准最佳实践。在下一节中，我们将讨论常见的包。

## 3.9 创建Utility包
上一节我们讨论了和包组织结构相关的标准实践。本节我们会讨论一个普遍的不好的实践：创建一个共享的包，例如utils，common或base。我们将看到这些方法的问题。

让我们看一个Go官方博客中涉及的例子。该例子是关于实现一个集合的数据结构的。map的value值被忽略。在Go中，惯用的方法是保持map[string]struct{}，因为struct{}类型表示我们对类型本身不感兴趣，我们可以传递长度为零的struct{}。让我们在util包中公开两个方法：
```golang
package util

func NewStringSet(...string) map[string]struct{} { ... } ①
func SortStringSet(map[string]struct{}) []string { ... } ②
```
① 创建一个字符串集合
② 返回一个按键排序的列表

使用该包的客户端会像下面这样：
```golang
set := util.NewStringSet("c", "a", "b")
fmt.Println(util.SortStringSet(set))
```
这里的问题是util是没有意义的。我们甚至是可以叫它common，shared或base，该名字没有任何价值。

相反，我们应该创建一个具有表现力的包名，例如stringset，例如：
```golang
package stringset
func New(...string) map[string]bool { ... }
func Sort(map[string]bool) []string { ... }
```
我们把函数NewStringSet和SortStringSet的后缀都移除了，变成了简单的New和Sort。从客户端来看，将会变成如下：
```golang
set := stringset.New("c", "a", "b")
fmt.Println(stringset.Sort(set))
```

我们甚至可以更进一步。我们可以创建一个特定的类型并导出Sort方法：
```golang
package stringset

type Set map[string]bool
func New(...string) Set { ... }
func (s Set) Sort() []string { ... }
```
这种改变将会使客户端更简单。这样仅有一个stringset的引用：
```golang
set := stringset.New("c", "a", "b")
fmt.Println(set.Sort())
```
这样一个小小的重构，我们就通过导出一个有表现力的API，从而避免了无意义报名的问题。

就像Dave Cheney所说的，找到处理公共设施的实用程序包是相当常见的。例如，客户端和服务器之间的公共类型。与其共享一个单独的包，不如减少包的数量并将它们合并到一个包中。

给包命名是应用程序设计的一个关键部分，我们应该对此保持谨慎，但是作为一般的经验法则，我们应该避免使用utility这样的包名。

下一节，我们将讨论包的冲突。

## 3.10 忽略了包名冲突













